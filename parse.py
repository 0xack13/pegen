#!/usr/bin/env python3.8
# @generated by pegen.py from data/simpy.gram
from __future__ import annotations

import ast
import sys
import tokenize

from pegen.parser import memoize, memoize_left_rec, logger, Parser


class GeneratedParser(Parser):

    @memoize
    def start(self):
        # start: statements? $
        mark = self.mark()
        cut = False
        if (
            (opt := self.statements(),)
            and
            (endmarker := self.expect('ENDMARKER'))
        ):
            return [opt, endmarker]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statements(self):
        # statements: (statement)+
        mark = self.mark()
        cut = False
        if (
            (_loop1_1 := self._loop1_1())
        ):
            return [_loop1_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statement(self):
        # statement: compound_stmt | simple_stmt
        mark = self.mark()
        cut = False
        if (
            (compound_stmt := self.compound_stmt())
        ):
            return [compound_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return [simple_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def simple_stmt(self):
        # simple_stmt: small_stmt ((';' small_stmt))* NEWLINE
        mark = self.mark()
        cut = False
        if (
            (small_stmt := self.small_stmt())
            and
            (_loop0_2 := self._loop0_2(),)
            and
            (newline := self.expect('NEWLINE'))
        ):
            return [small_stmt, _loop0_2, newline]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def small_stmt(self):
        # small_stmt: return_stmt | import_stmt | 'pass' | raise_stmt | yield_stmt | assert_stmt | del_stmt | global_stmt | nonlocal_stmt | assignment | expression
        mark = self.mark()
        cut = False
        if (
            (return_stmt := self.return_stmt())
        ):
            return [return_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (import_stmt := self.import_stmt())
        ):
            return [import_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('pass'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (raise_stmt := self.raise_stmt())
        ):
            return [raise_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (yield_stmt := self.yield_stmt())
        ):
            return [yield_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (assert_stmt := self.assert_stmt())
        ):
            return [assert_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (del_stmt := self.del_stmt())
        ):
            return [del_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (global_stmt := self.global_stmt())
        ):
            return [global_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (nonlocal_stmt := self.nonlocal_stmt())
        ):
            return [nonlocal_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (assignment := self.assignment())
        ):
            return [assignment]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (expression := self.expression())
        ):
            return [expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def compound_stmt(self):
        # compound_stmt: if_stmt | while_stmt | for_stmt | with_stmt | try_stmt | function_def | class_def
        mark = self.mark()
        cut = False
        if (
            (if_stmt := self.if_stmt())
        ):
            return [if_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (while_stmt := self.while_stmt())
        ):
            return [while_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (for_stmt := self.for_stmt())
        ):
            return [for_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (with_stmt := self.with_stmt())
        ):
            return [with_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (try_stmt := self.try_stmt())
        ):
            return [try_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (function_def := self.function_def())
        ):
            return [function_def]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (class_def := self.class_def())
        ):
            return [class_def]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def assignment(self):
        # assignment: target ':' expression '=' yield_expression? | ((star_targets '='))+ (yield_expr | expressions) | target augassign yield_expression
        mark = self.mark()
        cut = False
        if (
            (target := self.target())
            and
            (literal := self.expect(':'))
            and
            (expression := self.expression())
            and
            (opt := self._tmp_3(),)
        ):
            return [target, literal, expression, opt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_loop1_4 := self._loop1_4())
            and
            (_tmp_5 := self._tmp_5())
        ):
            return [_loop1_4, _tmp_5]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (target := self.target())
            and
            (augassign := self.augassign())
            and
            (yield_expression := self.yield_expression())
        ):
            return [target, augassign, yield_expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def augassign(self):
        # augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('+='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('-='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('@='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('/='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('%='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('&='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('|='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('^='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('<<='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('>>='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('//='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def global_stmt(self):
        # global_stmt: 'global' NAME ((',' NAME))*
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('global'))
            and
            (name := self.name())
            and
            (_loop0_6 := self._loop0_6(),)
        ):
            return [literal, name, _loop0_6]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def nonlocal_stmt(self):
        # nonlocal_stmt: 'nonlocal' NAME ((',' NAME))*
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('nonlocal'))
            and
            (name := self.name())
            and
            (_loop0_7 := self._loop0_7(),)
        ):
            return [literal, name, _loop0_7]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def yield_stmt(self):
        # yield_stmt: yield_expr
        mark = self.mark()
        cut = False
        if (
            (yield_expr := self.yield_expr())
        ):
            return [yield_expr]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def assert_stmt(self):
        # assert_stmt: 'assert' expression ',' expression?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('assert'))
            and
            (expression := self.expression())
            and
            (opt := self._tmp_8(),)
        ):
            return [literal, expression, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def del_stmt(self):
        # del_stmt: 'del' targets
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('del'))
            and
            (targets := self.targets())
        ):
            return [literal, targets]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_stmt(self):
        # import_stmt: import_name | import_from
        mark = self.mark()
        cut = False
        if (
            (import_name := self.import_name())
        ):
            return [import_name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (import_from := self.import_from())
        ):
            return [import_from]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_name(self):
        # import_name: 'import' dotted_as_names
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('import'))
            and
            (dotted_as_names := self.dotted_as_names())
        ):
            return [literal, dotted_as_names]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_from(self):
        # import_from: 'from' ((('.' | '...'))* !'import' dotted_name | (('.' | '...'))+) 'import' ('*' | '(' import_as_names ')' | import_as_names)
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('from'))
            and
            (_tmp_9 := self._tmp_9())
            and
            (literal_1 := self.expect('import'))
            and
            (_tmp_10 := self._tmp_10())
        ):
            return [literal, _tmp_9, literal_1, _tmp_10]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_as_name(self):
        # import_as_name: NAME 'as' NAME?
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (opt := self._tmp_11(),)
        ):
            return [name, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def dotted_as_name(self):
        # dotted_as_name: dotted_name 'as' NAME?
        mark = self.mark()
        cut = False
        if (
            (dotted_name := self.dotted_name())
            and
            (opt := self._tmp_12(),)
        ):
            return [dotted_name, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_as_names(self):
        # import_as_names: import_as_name ((',' import_as_name))* ','?
        mark = self.mark()
        cut = False
        if (
            (import_as_name := self.import_as_name())
            and
            (_loop0_13 := self._loop0_13(),)
            and
            (opt := self.expect(','),)
        ):
            return [import_as_name, _loop0_13, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def dotted_as_names(self):
        # dotted_as_names: dotted_as_name ((',' dotted_as_name))*
        mark = self.mark()
        cut = False
        if (
            (dotted_as_name := self.dotted_as_name())
            and
            (_loop0_14 := self._loop0_14(),)
        ):
            return [dotted_as_name, _loop0_14]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def dotted_name(self):
        # dotted_name: NAME (('.' NAME))*
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (_loop0_15 := self._loop0_15(),)
        ):
            return [name, _loop0_15]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def if_stmt(self):
        # if_stmt: 'if' full_expression ':' block (elif_block)* else_block?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('if'))
            and
            (full_expression := self.full_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
            and
            (_loop0_16 := self._loop0_16(),)
            and
            (opt := self.else_block(),)
        ):
            return [literal, full_expression, literal_1, block, _loop0_16, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def elif_block(self):
        # elif_block: 'elif' full_expression ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('elif'))
            and
            (full_expression := self.full_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [literal, full_expression, literal_1, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def else_block(self):
        # else_block: 'else' ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('else'))
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [literal, literal_1, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def while_stmt(self):
        # while_stmt: 'while' full_expression ':' block else_block?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('while'))
            and
            (full_expression := self.full_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
            and
            (opt := self.else_block(),)
        ):
            return [literal, full_expression, literal_1, block, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def for_stmt(self):
        # for_stmt: ASYNC? 'for' star_targets 'in' expressions ':' block else_block?
        mark = self.mark()
        cut = False
        if (
            (opt := self.expect('ASYNC'),)
            and
            (literal := self.expect('for'))
            and
            (star_targets := self.star_targets())
            and
            (literal_1 := self.expect('in'))
            and
            (expressions := self.expressions())
            and
            (literal_2 := self.expect(':'))
            and
            (block := self.block())
            and
            (opt_1 := self.else_block(),)
        ):
            return [opt, literal, star_targets, literal_1, expressions, literal_2, block, opt_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def with_stmt(self):
        # with_stmt: ASYNC? 'with' expression 'as' target? ':' block
        mark = self.mark()
        cut = False
        if (
            (opt := self.expect('ASYNC'),)
            and
            (literal := self.expect('with'))
            and
            (expression := self.expression())
            and
            (opt_1 := self._tmp_17(),)
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [opt, literal, expression, opt_1, literal_1, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def try_stmt(self):
        # try_stmt: try_block finally_block | try_block (except_block)+ else_block? finally_block?
        mark = self.mark()
        cut = False
        if (
            (try_block := self.try_block())
            and
            (finally_block := self.finally_block())
        ):
            return [try_block, finally_block]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (try_block := self.try_block())
            and
            (_loop1_18 := self._loop1_18())
            and
            (opt := self.else_block(),)
            and
            (opt_1 := self.finally_block(),)
        ):
            return [try_block, _loop1_18, opt, opt_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def try_block(self):
        # try_block: 'try' ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('try'))
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [literal, literal_1, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def except_block(self):
        # except_block: 'except' expression 'as' target?? ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('except'))
            and
            (opt := self._tmp_19(),)
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [literal, opt, literal_1, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def finally_block(self):
        # finally_block: 'finally' ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('finally'))
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [literal, literal_1, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def return_stmt(self):
        # return_stmt: 'return' expressions?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('return'))
            and
            (opt := self.expressions(),)
        ):
            return [literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def raise_stmt(self):
        # raise_stmt: 'raise' expression 'from' expression??
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('raise'))
            and
            (opt := self._tmp_20(),)
        ):
            return [literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def function_def(self):
        # function_def: decorators? ASYNC? 'def' NAME '(' parameters? ')' '->' expression? ':' block
        mark = self.mark()
        cut = False
        if (
            (opt := self.decorators(),)
            and
            (opt_1 := self.expect('ASYNC'),)
            and
            (literal := self.expect('def'))
            and
            (name := self.name())
            and
            (literal_1 := self.expect('('))
            and
            (opt_2 := self.parameters(),)
            and
            (literal_2 := self.expect(')'))
            and
            (opt_3 := self._tmp_21(),)
            and
            (literal_3 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [opt, opt_1, literal, name, literal_1, opt_2, literal_2, opt_3, literal_3, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def parameters(self):
        # parameters: slash_without_default ',' plain_names? ',' names_with_default? ',' star_etc?? | slash_with_default ',' names_with_default? ',' star_etc?? | plain_names ',' names_with_default? ',' star_etc?? | names_with_default ',' star_etc?? | star_etc
        mark = self.mark()
        cut = False
        if (
            (slash_without_default := self.slash_without_default())
            and
            (opt := self._tmp_22(),)
            and
            (opt_1 := self._tmp_23(),)
            and
            (opt_2 := self._tmp_24(),)
        ):
            return [slash_without_default, opt, opt_1, opt_2]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (slash_with_default := self.slash_with_default())
            and
            (opt := self._tmp_25(),)
            and
            (opt_1 := self._tmp_26(),)
        ):
            return [slash_with_default, opt, opt_1]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (plain_names := self.plain_names())
            and
            (opt := self._tmp_27(),)
            and
            (opt_1 := self._tmp_28(),)
        ):
            return [plain_names, opt, opt_1]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (names_with_default := self.names_with_default())
            and
            (opt := self._tmp_29(),)
        ):
            return [names_with_default, opt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (star_etc := self.star_etc())
        ):
            return [star_etc]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_etc(self):
        # star_etc: '*' NAME ':' annotation? ((',' plain_name '=' expression?))* ',' '**' NAME? ','? | '*' ((',' plain_name '=' expression?))+ ',' '**' NAME? ','? | '**' NAME ':' annotation? ','?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (name := self.name())
            and
            (opt := self._tmp_30(),)
            and
            (_loop0_31 := self._loop0_31(),)
            and
            (opt_1 := self._tmp_32(),)
            and
            (opt_2 := self.expect(','),)
        ):
            return [literal, name, opt, _loop0_31, opt_1, opt_2]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (_loop1_33 := self._loop1_33())
            and
            (opt := self._tmp_34(),)
            and
            (opt_1 := self.expect(','),)
        ):
            return [literal, _loop1_33, opt, opt_1]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**'))
            and
            (name := self.name())
            and
            (opt := self._tmp_35(),)
            and
            (opt_1 := self.expect(','),)
        ):
            return [literal, name, opt, opt_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def slash_without_default(self):
        # slash_without_default: plain_names ',' '/'
        mark = self.mark()
        cut = False
        if (
            (plain_names := self.plain_names())
            and
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('/'))
        ):
            return [plain_names, literal, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def slash_with_default(self):
        # slash_with_default: plain_names ','? names_with_default ',' '/'
        mark = self.mark()
        cut = False
        if (
            (opt := self._tmp_36(),)
            and
            (names_with_default := self.names_with_default())
            and
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('/'))
        ):
            return [opt, names_with_default, literal, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def names_with_default(self):
        # names_with_default: name_with_default ((',' name_with_default))*
        mark = self.mark()
        cut = False
        if (
            (name_with_default := self.name_with_default())
            and
            (_loop0_37 := self._loop0_37(),)
        ):
            return [name_with_default, _loop0_37]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def plain_names(self):
        # plain_names: plain_name !'=' ((',' plain_name !'='))*
        mark = self.mark()
        cut = False
        if (
            (plain_name := self.plain_name())
            and
            self.negative_lookahead(self.expect, '=')
            and
            (_loop0_38 := self._loop0_38(),)
        ):
            return [plain_name, _loop0_38]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def name_with_default(self):
        # name_with_default: plain_name '=' expression
        mark = self.mark()
        cut = False
        if (
            (plain_name := self.plain_name())
            and
            (literal := self.expect('='))
            and
            (expression := self.expression())
        ):
            return [plain_name, literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def plain_name(self):
        # plain_name: NAME ':' annotation?
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (opt := self._tmp_39(),)
        ):
            return [name, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def annotation(self):
        # annotation: expression
        mark = self.mark()
        cut = False
        if (
            (expression := self.expression())
        ):
            return [expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def decorators(self):
        # decorators: (('@' factor NEWLINE))+
        mark = self.mark()
        cut = False
        if (
            (_loop1_40 := self._loop1_40())
        ):
            return [_loop1_40]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def class_def(self):
        # class_def: decorators? 'class' NAME '(' full_expressions ')'? ':' block
        mark = self.mark()
        cut = False
        if (
            (opt := self.decorators(),)
            and
            (literal := self.expect('class'))
            and
            (name := self.name())
            and
            (opt_1 := self._tmp_41(),)
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [opt, literal, name, opt_1, literal_1, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def block(self):
        # block: simple_stmt | NEWLINE INDENT statements DEDENT
        mark = self.mark()
        cut = False
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return [simple_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (newline := self.expect('NEWLINE'))
            and
            (indent := self.expect('INDENT'))
            and
            (statements := self.statements())
            and
            (dedent := self.expect('DEDENT'))
        ):
            return [newline, indent, statements, dedent]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def full_expressions(self):
        # full_expressions: full_expression ((',' full_expression))* ','?
        mark = self.mark()
        cut = False
        if (
            (full_expression := self.full_expression())
            and
            (_loop0_42 := self._loop0_42(),)
            and
            (opt := self.expect(','),)
        ):
            return [full_expression, _loop0_42, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def expressions(self):
        # expressions: expression ((',' expression))* ','?
        mark = self.mark()
        cut = False
        if (
            (expression := self.expression())
            and
            (_loop0_43 := self._loop0_43(),)
            and
            (opt := self.expect(','),)
        ):
            return [expression, _loop0_43, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def full_expression(self):
        # full_expression: NAME ':=' expression | expression
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (literal := self.expect(':='))
            and
            (expression := self.expression())
        ):
            return [name, literal, expression]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (expression := self.expression())
        ):
            return [expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def yield_expression(self):
        # yield_expression: yield_expr | expression
        mark = self.mark()
        cut = False
        if (
            (yield_expr := self.yield_expr())
        ):
            return [yield_expr]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (expression := self.expression())
        ):
            return [expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def expression(self):
        # expression: lambdef | disjunction 'if' disjunction 'else' disjunction?
        mark = self.mark()
        cut = False
        if (
            (lambdef := self.lambdef())
        ):
            return [lambdef]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (disjunction := self.disjunction())
            and
            (opt := self._tmp_44(),)
        ):
            return [disjunction, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambdef(self):
        # lambdef: 'lambda' varargslist? ':' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('lambda'))
            and
            (opt := self.varargslist(),)
            and
            (literal_1 := self.expect(':'))
            and
            (expression := self.expression())
        ):
            return [literal, opt, literal_1, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def varargslist(self):
        # varargslist: NAME ((',' NAME))* ','?
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (_loop0_45 := self._loop0_45(),)
            and
            (opt := self.expect(','),)
        ):
            return [name, _loop0_45, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def disjunction(self):
        # disjunction: conjunction (('or' conjunction))*
        mark = self.mark()
        cut = False
        if (
            (conjunction := self.conjunction())
            and
            (_loop0_46 := self._loop0_46(),)
        ):
            return [conjunction, _loop0_46]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def conjunction(self):
        # conjunction: comparison (('and' comparison))*
        mark = self.mark()
        cut = False
        if (
            (comparison := self.comparison())
            and
            (_loop0_47 := self._loop0_47(),)
        ):
            return [comparison, _loop0_47]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def comparison(self):
        # comparison: ('not')* bitwise_or ((compare_op bitwise_or))*
        mark = self.mark()
        cut = False
        if (
            (_loop0_48 := self._loop0_48(),)
            and
            (bitwise_or := self.bitwise_or())
            and
            (_loop0_49 := self._loop0_49(),)
        ):
            return [_loop0_48, bitwise_or, _loop0_49]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def compare_op(self):
        # compare_op: '<' | '<=' | '==' | '>=' | '>' | '!=' | 'not'? 'in' | 'is' 'not'?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('<'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('<='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('=='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('>='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('>'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('!='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (opt := self.expect('not'),)
            and
            (literal := self.expect('in'))
        ):
            return [opt, literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('is'))
            and
            (opt := self.expect('not'),)
        ):
            return [literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def bitwise_or(self):
        # bitwise_or: bitwise_xor (('|' bitwise_xor))*
        mark = self.mark()
        cut = False
        if (
            (bitwise_xor := self.bitwise_xor())
            and
            (_loop0_50 := self._loop0_50(),)
        ):
            return [bitwise_xor, _loop0_50]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def bitwise_xor(self):
        # bitwise_xor: bitwise_and (('^' bitwise_and))*
        mark = self.mark()
        cut = False
        if (
            (bitwise_and := self.bitwise_and())
            and
            (_loop0_51 := self._loop0_51(),)
        ):
            return [bitwise_and, _loop0_51]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def bitwise_and(self):
        # bitwise_and: shift_expr (('&' shift_expr))*
        mark = self.mark()
        cut = False
        if (
            (shift_expr := self.shift_expr())
            and
            (_loop0_52 := self._loop0_52(),)
        ):
            return [shift_expr, _loop0_52]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def shift_expr(self):
        # shift_expr: sum ((('<<' | '>>') sum))*
        mark = self.mark()
        cut = False
        if (
            (sum := self.sum())
            and
            (_loop0_53 := self._loop0_53(),)
        ):
            return [sum, _loop0_53]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def sum(self):
        # sum: term ((('+' term | '-' term)))*
        mark = self.mark()
        cut = False
        if (
            (term := self.term())
            and
            (_loop0_54 := self._loop0_54(),)
        ):
            return [term, _loop0_54]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def term(self):
        # term: factor ((('*' factor | '/' factor | '//' factor | '%' factor | '@' factor)))*
        mark = self.mark()
        cut = False
        if (
            (factor := self.factor())
            and
            (_loop0_55 := self._loop0_55(),)
        ):
            return [factor, _loop0_55]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def factor(self):
        # factor: ('+' | '-' | '~') factor | power
        mark = self.mark()
        cut = False
        if (
            (_tmp_56 := self._tmp_56())
            and
            (factor := self.factor())
        ):
            return [_tmp_56, factor]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (power := self.power())
        ):
            return [power]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def power(self):
        # power: primary '**' factor | primary
        mark = self.mark()
        cut = False
        if (
            (primary := self.primary())
            and
            (literal := self.expect('**'))
            and
            (factor := self.factor())
        ):
            return [primary, literal, factor]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (primary := self.primary())
        ):
            return [primary]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def primary(self):
        # primary: AWAIT? atom (('.' NAME | '[' slices ']' | '(' arguments? ')'))*
        mark = self.mark()
        cut = False
        if (
            (opt := self.expect('AWAIT'),)
            and
            (atom := self.atom())
            and
            (_loop0_57 := self._loop0_57(),)
        ):
            return [opt, atom, _loop0_57]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def slices(self):
        # slices: slice ((',' slice))* ','?
        mark = self.mark()
        cut = False
        if (
            (slice := self.slice())
            and
            (_loop0_58 := self._loop0_58(),)
            and
            (opt := self.expect(','),)
        ):
            return [slice, _loop0_58, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def slice(self):
        # slice: expression? ':' expression? | expression
        mark = self.mark()
        cut = False
        if (
            (opt := self.expression(),)
            and
            (literal := self.expect(':'))
            and
            (opt_1 := self.expression(),)
        ):
            return [opt, literal, opt_1]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (expression := self.expression())
        ):
            return [expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def atom(self):
        # atom: list | listcomp | tuple | group | genexp | set | setcomp | dict | dictcomp | NAME | (STRING)+ | NUMBER | '...'
        mark = self.mark()
        cut = False
        if (
            (list := self.list())
        ):
            return [list]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (listcomp := self.listcomp())
        ):
            return [listcomp]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (tuple := self.tuple())
        ):
            return [tuple]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (group := self.group())
        ):
            return [group]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (genexp := self.genexp())
        ):
            return [genexp]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (set := self.set())
        ):
            return [set]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (setcomp := self.setcomp())
        ):
            return [setcomp]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (dict := self.dict())
        ):
            return [dict]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (dictcomp := self.dictcomp())
        ):
            return [dictcomp]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_loop1_59 := self._loop1_59())
        ):
            return [_loop1_59]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (number := self.number())
        ):
            return [number]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('...'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def list(self):
        # list: '[' full_expressions? ']'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('['))
            and
            (opt := self.full_expressions(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def listcomp(self):
        # listcomp: '[' expression for_if_clauses ']'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('['))
            and
            (expression := self.expression())
            and
            (for_if_clauses := self.for_if_clauses())
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, expression, for_if_clauses, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def tuple(self):
        # tuple: '(' full_expression ',' full_expressions?? ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (opt := self._tmp_60(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def group(self):
        # group: '(' (yield_expr | full_expression) ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (_tmp_61 := self._tmp_61())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, _tmp_61, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def genexp(self):
        # genexp: '(' expression for_if_clauses ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (expression := self.expression())
            and
            (for_if_clauses := self.for_if_clauses())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, expression, for_if_clauses, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def set(self):
        # set: '{' expressions '}'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (expressions := self.expressions())
            and
            (literal_1 := self.expect('}'))
        ):
            return [literal, expressions, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def setcomp(self):
        # setcomp: '{' expression for_if_clauses '}'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (expression := self.expression())
            and
            (for_if_clauses := self.for_if_clauses())
            and
            (literal_1 := self.expect('}'))
        ):
            return [literal, expression, for_if_clauses, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def dict(self):
        # dict: '{' kvpairs? '}'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (opt := self.kvpairs(),)
            and
            (literal_1 := self.expect('}'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def dictcomp(self):
        # dictcomp: '{' kvpair for_if_clauses '}'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (kvpair := self.kvpair())
            and
            (for_if_clauses := self.for_if_clauses())
            and
            (literal_1 := self.expect('}'))
        ):
            return [literal, kvpair, for_if_clauses, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kvpairs(self):
        # kvpairs: kvpair ((',' kvpair))* ','?
        mark = self.mark()
        cut = False
        if (
            (kvpair := self.kvpair())
            and
            (_loop0_62 := self._loop0_62(),)
            and
            (opt := self.expect(','),)
        ):
            return [kvpair, _loop0_62, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kvpair(self):
        # kvpair: expression ':' expression
        mark = self.mark()
        cut = False
        if (
            (expression := self.expression())
            and
            (literal := self.expect(':'))
            and
            (expression_1 := self.expression())
        ):
            return [expression, literal, expression_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def for_if_clauses(self):
        # for_if_clauses: (('for' star_targets 'in' expression (('if' expression))*))+
        mark = self.mark()
        cut = False
        if (
            (_loop1_63 := self._loop1_63())
        ):
            return [_loop1_63]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def yield_expr(self):
        # yield_expr: 'yield' 'from' expression | 'yield' expression?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('yield'))
            and
            (literal_1 := self.expect('from'))
            and
            (expression := self.expression())
        ):
            return [literal, literal_1, expression]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('yield'))
            and
            (opt := self.expression(),)
        ):
            return [literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def arguments(self):
        # arguments: expression for_if_clauses | args ','?
        mark = self.mark()
        cut = False
        if (
            (expression := self.expression())
            and
            (for_if_clauses := self.for_if_clauses())
        ):
            return [expression, for_if_clauses]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (args := self.args())
            and
            (opt := self.expect(','),)
        ):
            return [args, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def args(self):
        # args: kwargs | posarg ',' args?
        mark = self.mark()
        cut = False
        if (
            (kwargs := self.kwargs())
        ):
            return [kwargs]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (posarg := self.posarg())
            and
            (opt := self._tmp_64(),)
        ):
            return [posarg, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kwargs(self):
        # kwargs: kwarg ((',' kwarg))*
        mark = self.mark()
        cut = False
        if (
            (kwarg := self.kwarg())
            and
            (_loop0_65 := self._loop0_65(),)
        ):
            return [kwarg, _loop0_65]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def posarg(self):
        # posarg: full_expression | '*' expression
        mark = self.mark()
        cut = False
        if (
            (full_expression := self.full_expression())
        ):
            return [full_expression]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (expression := self.expression())
        ):
            return [literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kwarg(self):
        # kwarg: NAME '=' expression | '**' expression
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (literal := self.expect('='))
            and
            (expression := self.expression())
        ):
            return [name, literal, expression]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**'))
            and
            (expression := self.expression())
        ):
            return [literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_targets(self):
        # star_targets: star_target ((',' star_target))* ','?
        mark = self.mark()
        cut = False
        if (
            (star_target := self.star_target())
            and
            (_loop0_66 := self._loop0_66(),)
            and
            (opt := self.expect(','),)
        ):
            return [star_target, _loop0_66, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_target(self):
        # star_target: '*' NAME | star_atom (t_tail)*
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (star_atom := self.star_atom())
            and
            (_loop0_67 := self._loop0_67(),)
        ):
            return [star_atom, _loop0_67]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_atom(self):
        # star_atom: NAME | '(' star_targets? ')' | '[' star_targets? ']'
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (opt := self.star_targets(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('['))
            and
            (opt := self.star_targets(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def targets(self):
        # targets: target ((',' target))* ','?
        mark = self.mark()
        cut = False
        if (
            (target := self.target())
            and
            (_loop0_68 := self._loop0_68(),)
            and
            (opt := self.expect(','),)
        ):
            return [target, _loop0_68, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def target(self):
        # target: t_atom (t_tail)*
        mark = self.mark()
        cut = False
        if (
            (t_atom := self.t_atom())
            and
            (_loop0_69 := self._loop0_69(),)
        ):
            return [t_atom, _loop0_69]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def t_atom(self):
        # t_atom: NAME | '(' targets? ')' | '[' targets? ']'
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (opt := self.targets(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('['))
            and
            (opt := self.targets(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def t_tail(self):
        # t_tail: (call_tail)* (attr_tail | index_tail)
        mark = self.mark()
        cut = False
        if (
            (_loop0_70 := self._loop0_70(),)
            and
            (_tmp_71 := self._tmp_71())
        ):
            return [_loop0_70, _tmp_71]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def call_tail(self):
        # call_tail: '(' arguments? ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (opt := self.arguments(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def attr_tail(self):
        # attr_tail: '.' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('.'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def index_tail(self):
        # index_tail: '[' slices ']'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('['))
            and
            (slices := self.slices())
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, slices, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_1(self):
        # _loop1_1: statement
        mark = self.mark()
        children = []
        cut = False
        while (
            (statement := self.statement())
        ):
            children.append([statement])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_2(self):
        # _loop0_2: (';' small_stmt)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_72 := self._tmp_72())
        ):
            children.append([_tmp_72])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_3(self):
        # _tmp_3: '=' yield_expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('='))
            and
            (yield_expression := self.yield_expression())
        ):
            return [literal, yield_expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_4(self):
        # _loop1_4: (star_targets '=')
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_73 := self._tmp_73())
        ):
            children.append([_tmp_73])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_5(self):
        # _tmp_5: yield_expr | expressions
        mark = self.mark()
        cut = False
        if (
            (yield_expr := self.yield_expr())
        ):
            return [yield_expr]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (expressions := self.expressions())
        ):
            return [expressions]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_6(self):
        # _loop0_6: (',' NAME)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_74 := self._tmp_74())
        ):
            children.append([_tmp_74])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_7(self):
        # _loop0_7: (',' NAME)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_75 := self._tmp_75())
        ):
            children.append([_tmp_75])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_8(self):
        # _tmp_8: ',' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (expression := self.expression())
        ):
            return [literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_9(self):
        # _tmp_9: (('.' | '...'))* !'import' dotted_name | (('.' | '...'))+
        mark = self.mark()
        cut = False
        if (
            (_loop0_76 := self._loop0_76(),)
            and
            self.negative_lookahead(self.expect, 'import')
            and
            (dotted_name := self.dotted_name())
        ):
            return [_loop0_76, dotted_name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_loop1_77 := self._loop1_77())
        ):
            return [_loop1_77]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_10(self):
        # _tmp_10: '*' | '(' import_as_names ')' | import_as_names
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (import_as_names := self.import_as_names())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, import_as_names, literal_1]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (import_as_names := self.import_as_names())
        ):
            return [import_as_names]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_11(self):
        # _tmp_11: 'as' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('as'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_12(self):
        # _tmp_12: 'as' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('as'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_13(self):
        # _loop0_13: (',' import_as_name)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_78 := self._tmp_78())
        ):
            children.append([_tmp_78])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_14(self):
        # _loop0_14: (',' dotted_as_name)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_79 := self._tmp_79())
        ):
            children.append([_tmp_79])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_15(self):
        # _loop0_15: ('.' NAME)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_80 := self._tmp_80())
        ):
            children.append([_tmp_80])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_16(self):
        # _loop0_16: elif_block
        mark = self.mark()
        children = []
        cut = False
        while (
            (elif_block := self.elif_block())
        ):
            children.append([elif_block])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_17(self):
        # _tmp_17: 'as' target
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('as'))
            and
            (target := self.target())
        ):
            return [literal, target]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_18(self):
        # _loop1_18: except_block
        mark = self.mark()
        children = []
        cut = False
        while (
            (except_block := self.except_block())
        ):
            children.append([except_block])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_19(self):
        # _tmp_19: expression 'as' target?
        mark = self.mark()
        cut = False
        if (
            (expression := self.expression())
            and
            (opt := self._tmp_81(),)
        ):
            return [expression, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_20(self):
        # _tmp_20: expression 'from' expression?
        mark = self.mark()
        cut = False
        if (
            (expression := self.expression())
            and
            (opt := self._tmp_82(),)
        ):
            return [expression, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_21(self):
        # _tmp_21: '->' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('->'))
            and
            (expression := self.expression())
        ):
            return [literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_22(self):
        # _tmp_22: ',' plain_names
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (plain_names := self.plain_names())
        ):
            return [literal, plain_names]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_23(self):
        # _tmp_23: ',' names_with_default
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (names_with_default := self.names_with_default())
        ):
            return [literal, names_with_default]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_24(self):
        # _tmp_24: ',' star_etc?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (opt := self.star_etc(),)
        ):
            return [literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_25(self):
        # _tmp_25: ',' names_with_default
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (names_with_default := self.names_with_default())
        ):
            return [literal, names_with_default]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_26(self):
        # _tmp_26: ',' star_etc?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (opt := self.star_etc(),)
        ):
            return [literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_27(self):
        # _tmp_27: ',' names_with_default
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (names_with_default := self.names_with_default())
        ):
            return [literal, names_with_default]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_28(self):
        # _tmp_28: ',' star_etc?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (opt := self.star_etc(),)
        ):
            return [literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_29(self):
        # _tmp_29: ',' star_etc?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (opt := self.star_etc(),)
        ):
            return [literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_30(self):
        # _tmp_30: ':' annotation
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(':'))
            and
            (annotation := self.annotation())
        ):
            return [literal, annotation]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_31(self):
        # _loop0_31: (',' plain_name '=' expression?)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_83 := self._tmp_83())
        ):
            children.append([_tmp_83])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_32(self):
        # _tmp_32: ',' '**' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('**'))
            and
            (name := self.name())
        ):
            return [literal, literal_1, name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_33(self):
        # _loop1_33: (',' plain_name '=' expression?)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_84 := self._tmp_84())
        ):
            children.append([_tmp_84])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_34(self):
        # _tmp_34: ',' '**' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('**'))
            and
            (name := self.name())
        ):
            return [literal, literal_1, name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_35(self):
        # _tmp_35: ':' annotation
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(':'))
            and
            (annotation := self.annotation())
        ):
            return [literal, annotation]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_36(self):
        # _tmp_36: plain_names ','
        mark = self.mark()
        cut = False
        if (
            (plain_names := self.plain_names())
            and
            (literal := self.expect(','))
        ):
            return [plain_names, literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_37(self):
        # _loop0_37: (',' name_with_default)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_85 := self._tmp_85())
        ):
            children.append([_tmp_85])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_38(self):
        # _loop0_38: (',' plain_name !'=')
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_86 := self._tmp_86())
        ):
            children.append([_tmp_86])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_39(self):
        # _tmp_39: ':' annotation
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(':'))
            and
            (annotation := self.annotation())
        ):
            return [literal, annotation]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_40(self):
        # _loop1_40: ('@' factor NEWLINE)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_87 := self._tmp_87())
        ):
            children.append([_tmp_87])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_41(self):
        # _tmp_41: '(' full_expressions ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (full_expressions := self.full_expressions())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, full_expressions, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_42(self):
        # _loop0_42: (',' full_expression)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_88 := self._tmp_88())
        ):
            children.append([_tmp_88])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_43(self):
        # _loop0_43: (',' expression)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_89 := self._tmp_89())
        ):
            children.append([_tmp_89])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_44(self):
        # _tmp_44: 'if' disjunction 'else' disjunction
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('if'))
            and
            (disjunction := self.disjunction())
            and
            (literal_1 := self.expect('else'))
            and
            (disjunction_1 := self.disjunction())
        ):
            return [literal, disjunction, literal_1, disjunction_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_45(self):
        # _loop0_45: (',' NAME)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_90 := self._tmp_90())
        ):
            children.append([_tmp_90])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_46(self):
        # _loop0_46: ('or' conjunction)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_91 := self._tmp_91())
        ):
            children.append([_tmp_91])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_47(self):
        # _loop0_47: ('and' comparison)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_92 := self._tmp_92())
        ):
            children.append([_tmp_92])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_48(self):
        # _loop0_48: 'not'
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect('not'))
        ):
            children.append([literal])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_49(self):
        # _loop0_49: (compare_op bitwise_or)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_93 := self._tmp_93())
        ):
            children.append([_tmp_93])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_50(self):
        # _loop0_50: ('|' bitwise_xor)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_94 := self._tmp_94())
        ):
            children.append([_tmp_94])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_51(self):
        # _loop0_51: ('^' bitwise_and)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_95 := self._tmp_95())
        ):
            children.append([_tmp_95])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_52(self):
        # _loop0_52: ('&' shift_expr)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_96 := self._tmp_96())
        ):
            children.append([_tmp_96])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_53(self):
        # _loop0_53: (('<<' | '>>') sum)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_97 := self._tmp_97())
        ):
            children.append([_tmp_97])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_54(self):
        # _loop0_54: (('+' term | '-' term))
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_98 := self._tmp_98())
        ):
            children.append([_tmp_98])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_55(self):
        # _loop0_55: (('*' factor | '/' factor | '//' factor | '%' factor | '@' factor))
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_99 := self._tmp_99())
        ):
            children.append([_tmp_99])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_56(self):
        # _tmp_56: '+' | '-' | '~'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('+'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('-'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('~'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_57(self):
        # _loop0_57: ('.' NAME | '[' slices ']' | '(' arguments? ')')
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_100 := self._tmp_100())
        ):
            children.append([_tmp_100])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_58(self):
        # _loop0_58: (',' slice)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_101 := self._tmp_101())
        ):
            children.append([_tmp_101])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_59(self):
        # _loop1_59: STRING
        mark = self.mark()
        children = []
        cut = False
        while (
            (string := self.string())
        ):
            children.append([string])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_60(self):
        # _tmp_60: full_expression ',' full_expressions?
        mark = self.mark()
        cut = False
        if (
            (full_expression := self.full_expression())
            and
            (literal := self.expect(','))
            and
            (opt := self.full_expressions(),)
        ):
            return [full_expression, literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_61(self):
        # _tmp_61: yield_expr | full_expression
        mark = self.mark()
        cut = False
        if (
            (yield_expr := self.yield_expr())
        ):
            return [yield_expr]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (full_expression := self.full_expression())
        ):
            return [full_expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_62(self):
        # _loop0_62: (',' kvpair)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_102 := self._tmp_102())
        ):
            children.append([_tmp_102])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_63(self):
        # _loop1_63: ('for' star_targets 'in' expression (('if' expression))*)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_103 := self._tmp_103())
        ):
            children.append([_tmp_103])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_64(self):
        # _tmp_64: ',' args
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (args := self.args())
        ):
            return [literal, args]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_65(self):
        # _loop0_65: (',' kwarg)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_104 := self._tmp_104())
        ):
            children.append([_tmp_104])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_66(self):
        # _loop0_66: (',' star_target)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_105 := self._tmp_105())
        ):
            children.append([_tmp_105])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_67(self):
        # _loop0_67: t_tail
        mark = self.mark()
        children = []
        cut = False
        while (
            (t_tail := self.t_tail())
        ):
            children.append([t_tail])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_68(self):
        # _loop0_68: (',' target)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_106 := self._tmp_106())
        ):
            children.append([_tmp_106])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_69(self):
        # _loop0_69: t_tail
        mark = self.mark()
        children = []
        cut = False
        while (
            (t_tail := self.t_tail())
        ):
            children.append([t_tail])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_70(self):
        # _loop0_70: call_tail
        mark = self.mark()
        children = []
        cut = False
        while (
            (call_tail := self.call_tail())
        ):
            children.append([call_tail])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_71(self):
        # _tmp_71: attr_tail | index_tail
        mark = self.mark()
        cut = False
        if (
            (attr_tail := self.attr_tail())
        ):
            return [attr_tail]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (index_tail := self.index_tail())
        ):
            return [index_tail]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_72(self):
        # _tmp_72: ';' small_stmt
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(';'))
            and
            (small_stmt := self.small_stmt())
        ):
            return [literal, small_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_73(self):
        # _tmp_73: star_targets '='
        mark = self.mark()
        cut = False
        if (
            (star_targets := self.star_targets())
            and
            (literal := self.expect('='))
        ):
            return [star_targets, literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_74(self):
        # _tmp_74: ',' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_75(self):
        # _tmp_75: ',' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_76(self):
        # _loop0_76: ('.' | '...')
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_107 := self._tmp_107())
        ):
            children.append([_tmp_107])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_77(self):
        # _loop1_77: ('.' | '...')
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_108 := self._tmp_108())
        ):
            children.append([_tmp_108])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_78(self):
        # _tmp_78: ',' import_as_name
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (import_as_name := self.import_as_name())
        ):
            return [literal, import_as_name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_79(self):
        # _tmp_79: ',' dotted_as_name
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (dotted_as_name := self.dotted_as_name())
        ):
            return [literal, dotted_as_name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_80(self):
        # _tmp_80: '.' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('.'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_81(self):
        # _tmp_81: 'as' target
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('as'))
            and
            (target := self.target())
        ):
            return [literal, target]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_82(self):
        # _tmp_82: 'from' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('from'))
            and
            (expression := self.expression())
        ):
            return [literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_83(self):
        # _tmp_83: ',' plain_name '=' expression?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (plain_name := self.plain_name())
            and
            (opt := self._tmp_109(),)
        ):
            return [literal, plain_name, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_84(self):
        # _tmp_84: ',' plain_name '=' expression?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (plain_name := self.plain_name())
            and
            (opt := self._tmp_110(),)
        ):
            return [literal, plain_name, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_85(self):
        # _tmp_85: ',' name_with_default
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (name_with_default := self.name_with_default())
        ):
            return [literal, name_with_default]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_86(self):
        # _tmp_86: ',' plain_name !'='
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (plain_name := self.plain_name())
            and
            self.negative_lookahead(self.expect, '=')
        ):
            return [literal, plain_name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_87(self):
        # _tmp_87: '@' factor NEWLINE
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('@'))
            and
            (factor := self.factor())
            and
            (newline := self.expect('NEWLINE'))
        ):
            return [literal, factor, newline]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_88(self):
        # _tmp_88: ',' full_expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (full_expression := self.full_expression())
        ):
            return [literal, full_expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_89(self):
        # _tmp_89: ',' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (expression := self.expression())
        ):
            return [literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_90(self):
        # _tmp_90: ',' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_91(self):
        # _tmp_91: 'or' conjunction
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('or'))
            and
            (conjunction := self.conjunction())
        ):
            return [literal, conjunction]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_92(self):
        # _tmp_92: 'and' comparison
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('and'))
            and
            (comparison := self.comparison())
        ):
            return [literal, comparison]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_93(self):
        # _tmp_93: compare_op bitwise_or
        mark = self.mark()
        cut = False
        if (
            (compare_op := self.compare_op())
            and
            (bitwise_or := self.bitwise_or())
        ):
            return [compare_op, bitwise_or]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_94(self):
        # _tmp_94: '|' bitwise_xor
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('|'))
            and
            (bitwise_xor := self.bitwise_xor())
        ):
            return [literal, bitwise_xor]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_95(self):
        # _tmp_95: '^' bitwise_and
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('^'))
            and
            (bitwise_and := self.bitwise_and())
        ):
            return [literal, bitwise_and]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_96(self):
        # _tmp_96: '&' shift_expr
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('&'))
            and
            (shift_expr := self.shift_expr())
        ):
            return [literal, shift_expr]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_97(self):
        # _tmp_97: ('<<' | '>>') sum
        mark = self.mark()
        cut = False
        if (
            (_tmp_111 := self._tmp_111())
            and
            (sum := self.sum())
        ):
            return [_tmp_111, sum]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_98(self):
        # _tmp_98: '+' term | '-' term
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('+'))
            and
            (term := self.term())
        ):
            return [literal, term]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('-'))
            and
            (term := self.term())
        ):
            return [literal, term]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_99(self):
        # _tmp_99: '*' factor | '/' factor | '//' factor | '%' factor | '@' factor
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (factor := self.factor())
        ):
            return [literal, factor]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('/'))
            and
            (factor := self.factor())
        ):
            return [literal, factor]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('//'))
            and
            (factor := self.factor())
        ):
            return [literal, factor]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('%'))
            and
            (factor := self.factor())
        ):
            return [literal, factor]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('@'))
            and
            (factor := self.factor())
        ):
            return [literal, factor]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_100(self):
        # _tmp_100: '.' NAME | '[' slices ']' | '(' arguments? ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('.'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('['))
            and
            (slices := self.slices())
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, slices, literal_1]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (opt := self.arguments(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_101(self):
        # _tmp_101: ',' slice
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (slice := self.slice())
        ):
            return [literal, slice]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_102(self):
        # _tmp_102: ',' kvpair
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (kvpair := self.kvpair())
        ):
            return [literal, kvpair]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_103(self):
        # _tmp_103: 'for' star_targets 'in' expression (('if' expression))*
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('for'))
            and
            (star_targets := self.star_targets())
            and
            (literal_1 := self.expect('in'))
            and
            (expression := self.expression())
            and
            (_loop0_112 := self._loop0_112(),)
        ):
            return [literal, star_targets, literal_1, expression, _loop0_112]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_104(self):
        # _tmp_104: ',' kwarg
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (kwarg := self.kwarg())
        ):
            return [literal, kwarg]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_105(self):
        # _tmp_105: ',' star_target
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (star_target := self.star_target())
        ):
            return [literal, star_target]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_106(self):
        # _tmp_106: ',' target
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (target := self.target())
        ):
            return [literal, target]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_107(self):
        # _tmp_107: '.' | '...'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('.'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('...'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_108(self):
        # _tmp_108: '.' | '...'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('.'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('...'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_109(self):
        # _tmp_109: '=' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('='))
            and
            (expression := self.expression())
        ):
            return [literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_110(self):
        # _tmp_110: '=' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('='))
            and
            (expression := self.expression())
        ):
            return [literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_111(self):
        # _tmp_111: '<<' | '>>'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('<<'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('>>'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_112(self):
        # _loop0_112: ('if' expression)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_113 := self._tmp_113())
        ):
            children.append([_tmp_113])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_113(self):
        # _tmp_113: 'if' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('if'))
            and
            (expression := self.expression())
        ):
            return [literal, expression]
        self.reset(mark)
        if cut: return None
        return None


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
