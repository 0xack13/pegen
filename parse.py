#!/usr/bin/env python3.8
# @generated by pegen.py from data/simpy.gram
from __future__ import annotations

import ast
import sys
import tokenize

from pegen import memoize, memoize_left_rec, Parser


class GeneratedParser(Parser):

    @memoize
    def start(self):
        # start: statements $
        mark = self.mark()
        cut = False
        if (
            (statements := self.statements())
            and
            (endmarker := self.expect('ENDMARKER'))
        ):
            return [statements, endmarker]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statements(self):
        # statements: (statement)+
        mark = self.mark()
        cut = False
        if (
            (_loop1_1 := self._loop1_1())
        ):
            return [_loop1_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statement(self):
        # statement: simple_stmt | compound_stmt
        mark = self.mark()
        cut = False
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return [simple_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (compound_stmt := self.compound_stmt())
        ):
            return [compound_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def simple_stmt(self):
        # simple_stmt: small_stmt ((';' small_stmt))* NEWLINE
        mark = self.mark()
        cut = False
        if (
            (small_stmt := self.small_stmt())
            and
            (_loop0_2 := self._loop0_2(),)
            and
            (newline := self.expect('NEWLINE'))
        ):
            return [small_stmt, _loop0_2, newline]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def small_stmt(self):
        # small_stmt: return_stmt | import_stmt | 'pass' | assignment | expression
        mark = self.mark()
        cut = False
        if (
            (return_stmt := self.return_stmt())
        ):
            return [return_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (import_stmt := self.import_stmt())
        ):
            return [import_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('pass'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (assignment := self.assignment())
        ):
            return [assignment]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (expression := self.expression())
        ):
            return [expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def compound_stmt(self):
        # compound_stmt: if_stmt | while_stmt | with_stmt | function_def | class_def
        mark = self.mark()
        cut = False
        if (
            (if_stmt := self.if_stmt())
        ):
            return [if_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (while_stmt := self.while_stmt())
        ):
            return [while_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (with_stmt := self.with_stmt())
        ):
            return [with_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (function_def := self.function_def())
        ):
            return [function_def]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (class_def := self.class_def())
        ):
            return [class_def]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def assignment(self):
        # assignment: target '=' expression
        mark = self.mark()
        cut = False
        if (
            (target := self.target())
            and
            (literal := self.expect('='))
            and
            (expression := self.expression())
        ):
            return [target, literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_stmt(self):
        # import_stmt: 'import' names | 'from' NAME 'import' ('*' | names)
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('import'))
            and
            (names := self.names())
        ):
            return [literal, names]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('from'))
            and
            (name := self.name())
            and
            (literal_1 := self.expect('import'))
            and
            (_tmp_3 := self._tmp_3())
        ):
            return [literal, name, literal_1, _tmp_3]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def names(self):
        # names: NAME ',' names | NAME
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (literal := self.expect(','))
            and
            (names := self.names())
        ):
            return [name, literal, names]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def if_stmt(self):
        # if_stmt: 'if' full_expression ':' block (elif_block)* else_block?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('if'))
            and
            (full_expression := self.full_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
            and
            (_loop0_4 := self._loop0_4(),)
            and
            (opt := self.else_block(),)
        ):
            return [literal, full_expression, literal_1, block, _loop0_4, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def elif_block(self):
        # elif_block: 'elif' full_expression ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('elif'))
            and
            (full_expression := self.full_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [literal, full_expression, literal_1, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def else_block(self):
        # else_block: 'else' ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('else'))
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [literal, literal_1, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def while_stmt(self):
        # while_stmt: 'while' full_expression ':' block else_block?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('while'))
            and
            (full_expression := self.full_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
            and
            (opt := self.else_block(),)
        ):
            return [literal, full_expression, literal_1, block, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def with_stmt(self):
        # with_stmt: 'with' expression 'as' target? ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('with'))
            and
            (expression := self.expression())
            and
            (opt := self._tmp_5(),)
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [literal, expression, opt, literal_1, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def return_stmt(self):
        # return_stmt: 'return' expressions?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('return'))
            and
            (opt := self.expressions(),)
        ):
            return [literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def function_def(self):
        # function_def: decorators? 'def' NAME '(' parameters? ')' ':' block
        mark = self.mark()
        cut = False
        if (
            (opt := self.decorators(),)
            and
            (literal := self.expect('def'))
            and
            (name := self.name())
            and
            (literal_1 := self.expect('('))
            and
            (opt_1 := self.parameters(),)
            and
            (literal_2 := self.expect(')'))
            and
            (literal_3 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [opt, literal, name, literal_1, opt_1, literal_2, literal_3, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def parameters(self):
        # parameters: kwparams | param ',' parameters??
        mark = self.mark()
        cut = False
        if (
            (kwparams := self.kwparams())
        ):
            return [kwparams]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (param := self.param())
            and
            (opt := self._tmp_6(),)
        ):
            return [param, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kwparams(self):
        # kwparams: kwparam ',' kwparams??
        mark = self.mark()
        cut = False
        if (
            (kwparam := self.kwparam())
            and
            (opt := self._tmp_7(),)
        ):
            return [kwparam, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kwparam(self):
        # kwparam: NAME '=' expression | '**' NAME
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (literal := self.expect('='))
            and
            (expression := self.expression())
        ):
            return [name, literal, expression]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def param(self):
        # param: NAME | '*' NAME
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def decorators(self):
        # decorators: (('@' factor NEWLINE))+
        mark = self.mark()
        cut = False
        if (
            (_loop1_8 := self._loop1_8())
        ):
            return [_loop1_8]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def class_def(self):
        # class_def: decorators? 'class' NAME '(' full_expressions ')'? ':' block
        mark = self.mark()
        cut = False
        if (
            (opt := self.decorators(),)
            and
            (literal := self.expect('class'))
            and
            (name := self.name())
            and
            (opt_1 := self._tmp_9(),)
            and
            (literal_1 := self.expect(':'))
            and
            (block := self.block())
        ):
            return [opt, literal, name, opt_1, literal_1, block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def block(self):
        # block: simple_stmt | NEWLINE INDENT statements DEDENT
        mark = self.mark()
        cut = False
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return [simple_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (newline := self.expect('NEWLINE'))
            and
            (indent := self.expect('INDENT'))
            and
            (statements := self.statements())
            and
            (dedent := self.expect('DEDENT'))
        ):
            return [newline, indent, statements, dedent]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def full_expressions(self):
        # full_expressions: full_expression ((',' full_expression))* ','?
        mark = self.mark()
        cut = False
        if (
            (full_expression := self.full_expression())
            and
            (_loop0_10 := self._loop0_10(),)
            and
            (opt := self.expect(','),)
        ):
            return [full_expression, _loop0_10, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def full_expression(self):
        # full_expression: NAME ':=' disjunction | disjunction
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (literal := self.expect(':='))
            and
            (disjunction := self.disjunction())
        ):
            return [name, literal, disjunction]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (disjunction := self.disjunction())
        ):
            return [disjunction]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def disjunction(self):
        # disjunction: conjunction (('or' conjunction))*
        mark = self.mark()
        cut = False
        if (
            (conjunction := self.conjunction())
            and
            (_loop0_11 := self._loop0_11(),)
        ):
            return [conjunction, _loop0_11]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def conjunction(self):
        # conjunction: comparison (('and' comparison))*
        mark = self.mark()
        cut = False
        if (
            (comparison := self.comparison())
            and
            (_loop0_12 := self._loop0_12(),)
        ):
            return [comparison, _loop0_12]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def comparison(self):
        # comparison: ('not')* bitwise_or ((compare_op bitwise_or))*
        mark = self.mark()
        cut = False
        if (
            (_loop0_13 := self._loop0_13(),)
            and
            (bitwise_or := self.bitwise_or())
            and
            (_loop0_14 := self._loop0_14(),)
        ):
            return [_loop0_13, bitwise_or, _loop0_14]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def compare_op(self):
        # compare_op: '<' | '<=' | '==' | '>=' | '>' | '!=' | 'in' | 'not in'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('<'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('<='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('=='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('>='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('>'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('!='))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('in'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('not in'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def bitwise_or(self):
        # bitwise_or: bitwise_and (('|' bitwise_and))*
        mark = self.mark()
        cut = False
        if (
            (bitwise_and := self.bitwise_and())
            and
            (_loop0_15 := self._loop0_15(),)
        ):
            return [bitwise_and, _loop0_15]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def bitwise_and(self):
        # bitwise_and: expression (('&' expression))*
        mark = self.mark()
        cut = False
        if (
            (expression := self.expression())
            and
            (_loop0_16 := self._loop0_16(),)
        ):
            return [expression, _loop0_16]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def expressions(self):
        # expressions: expression ((',' expression))* ','?
        mark = self.mark()
        cut = False
        if (
            (expression := self.expression())
            and
            (_loop0_17 := self._loop0_17(),)
            and
            (opt := self.expect(','),)
        ):
            return [expression, _loop0_17, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def expression(self):
        # expression: term ((('+' term | '-' term)))*
        mark = self.mark()
        cut = False
        if (
            (term := self.term())
            and
            (_loop0_18 := self._loop0_18(),)
        ):
            return [term, _loop0_18]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def term(self):
        # term: factor ((('*' factor | '/' factor)))*
        mark = self.mark()
        cut = False
        if (
            (factor := self.factor())
            and
            (_loop0_19 := self._loop0_19(),)
        ):
            return [factor, _loop0_19]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def factor(self):
        # factor: primary (('.' NAME | '[' expression ']' | '(' arguments ','?? ')'))*
        mark = self.mark()
        cut = False
        if (
            (primary := self.primary())
            and
            (_loop0_20 := self._loop0_20(),)
        ):
            return [primary, _loop0_20]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def primary(self):
        # primary: list | tuple | group | NAME | STRING | NUMBER
        mark = self.mark()
        cut = False
        if (
            (list := self.list())
        ):
            return [list]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (tuple := self.tuple())
        ):
            return [tuple]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (group := self.group())
        ):
            return [group]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (string := self.string())
        ):
            return [string]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (number := self.number())
        ):
            return [number]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def list(self):
        # list: '[' full_expressions? ']'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('['))
            and
            (opt := self.full_expressions(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def tuple(self):
        # tuple: '(' full_expression ',' full_expressions?? ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (opt := self._tmp_21(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def group(self):
        # group: '(' full_expression ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (full_expression := self.full_expression())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, full_expression, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def arguments(self):
        # arguments: kwargs | posarg ',' arguments?
        mark = self.mark()
        cut = False
        if (
            (kwargs := self.kwargs())
        ):
            return [kwargs]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (posarg := self.posarg())
            and
            (opt := self._tmp_22(),)
        ):
            return [posarg, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kwargs(self):
        # kwargs: kwarg ((',' kwarg))*
        mark = self.mark()
        cut = False
        if (
            (kwarg := self.kwarg())
            and
            (_loop0_23 := self._loop0_23(),)
        ):
            return [kwarg, _loop0_23]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def posarg(self):
        # posarg: full_expression | '*' disjunction
        mark = self.mark()
        cut = False
        if (
            (full_expression := self.full_expression())
        ):
            return [full_expression]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (disjunction := self.disjunction())
        ):
            return [literal, disjunction]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kwarg(self):
        # kwarg: NAME '=' disjunction | '**' disjunction
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (literal := self.expect('='))
            and
            (disjunction := self.disjunction())
        ):
            return [name, literal, disjunction]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**'))
            and
            (disjunction := self.disjunction())
        ):
            return [literal, disjunction]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def target(self):
        # target: NAME
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_1(self):
        # _loop1_1: statement
        mark = self.mark()
        children = []
        cut = False
        while (
            (statement := self.statement())
        ):
            children.append([statement])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_2(self):
        # _loop0_2: (';' small_stmt)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_24 := self._tmp_24())
        ):
            children.append([_tmp_24])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_3(self):
        # _tmp_3: '*' | names
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (names := self.names())
        ):
            return [names]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_4(self):
        # _loop0_4: elif_block
        mark = self.mark()
        children = []
        cut = False
        while (
            (elif_block := self.elif_block())
        ):
            children.append([elif_block])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_5(self):
        # _tmp_5: 'as' target
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('as'))
            and
            (target := self.target())
        ):
            return [literal, target]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_6(self):
        # _tmp_6: ',' parameters?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (opt := self.parameters(),)
        ):
            return [literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_7(self):
        # _tmp_7: ',' kwparams?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (opt := self.kwparams(),)
        ):
            return [literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_8(self):
        # _loop1_8: ('@' factor NEWLINE)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_25 := self._tmp_25())
        ):
            children.append([_tmp_25])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_9(self):
        # _tmp_9: '(' full_expressions ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (full_expressions := self.full_expressions())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, full_expressions, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_10(self):
        # _loop0_10: (',' full_expression)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_26 := self._tmp_26())
        ):
            children.append([_tmp_26])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_11(self):
        # _loop0_11: ('or' conjunction)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_27 := self._tmp_27())
        ):
            children.append([_tmp_27])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_12(self):
        # _loop0_12: ('and' comparison)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_28 := self._tmp_28())
        ):
            children.append([_tmp_28])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_13(self):
        # _loop0_13: 'not'
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect('not'))
        ):
            children.append([literal])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_14(self):
        # _loop0_14: (compare_op bitwise_or)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_29 := self._tmp_29())
        ):
            children.append([_tmp_29])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_15(self):
        # _loop0_15: ('|' bitwise_and)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_30 := self._tmp_30())
        ):
            children.append([_tmp_30])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_16(self):
        # _loop0_16: ('&' expression)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_31 := self._tmp_31())
        ):
            children.append([_tmp_31])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_17(self):
        # _loop0_17: (',' expression)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_32 := self._tmp_32())
        ):
            children.append([_tmp_32])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_18(self):
        # _loop0_18: (('+' term | '-' term))
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_33 := self._tmp_33())
        ):
            children.append([_tmp_33])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_19(self):
        # _loop0_19: (('*' factor | '/' factor))
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_34 := self._tmp_34())
        ):
            children.append([_tmp_34])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_20(self):
        # _loop0_20: ('.' NAME | '[' expression ']' | '(' arguments ','?? ')')
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_35 := self._tmp_35())
        ):
            children.append([_tmp_35])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_21(self):
        # _tmp_21: full_expression ',' full_expressions?
        mark = self.mark()
        cut = False
        if (
            (full_expression := self.full_expression())
            and
            (literal := self.expect(','))
            and
            (opt := self.full_expressions(),)
        ):
            return [full_expression, literal, opt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_22(self):
        # _tmp_22: ',' arguments
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (arguments := self.arguments())
        ):
            return [literal, arguments]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_23(self):
        # _loop0_23: (',' kwarg)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_36 := self._tmp_36())
        ):
            children.append([_tmp_36])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_24(self):
        # _tmp_24: ';' small_stmt
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(';'))
            and
            (small_stmt := self.small_stmt())
        ):
            return [literal, small_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_25(self):
        # _tmp_25: '@' factor NEWLINE
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('@'))
            and
            (factor := self.factor())
            and
            (newline := self.expect('NEWLINE'))
        ):
            return [literal, factor, newline]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_26(self):
        # _tmp_26: ',' full_expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (full_expression := self.full_expression())
        ):
            return [literal, full_expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_27(self):
        # _tmp_27: 'or' conjunction
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('or'))
            and
            (conjunction := self.conjunction())
        ):
            return [literal, conjunction]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_28(self):
        # _tmp_28: 'and' comparison
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('and'))
            and
            (comparison := self.comparison())
        ):
            return [literal, comparison]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_29(self):
        # _tmp_29: compare_op bitwise_or
        mark = self.mark()
        cut = False
        if (
            (compare_op := self.compare_op())
            and
            (bitwise_or := self.bitwise_or())
        ):
            return [compare_op, bitwise_or]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_30(self):
        # _tmp_30: '|' bitwise_and
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('|'))
            and
            (bitwise_and := self.bitwise_and())
        ):
            return [literal, bitwise_and]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_31(self):
        # _tmp_31: '&' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('&'))
            and
            (expression := self.expression())
        ):
            return [literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_32(self):
        # _tmp_32: ',' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (expression := self.expression())
        ):
            return [literal, expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_33(self):
        # _tmp_33: '+' term | '-' term
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('+'))
            and
            (term := self.term())
        ):
            return [literal, term]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('-'))
            and
            (term := self.term())
        ):
            return [literal, term]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_34(self):
        # _tmp_34: '*' factor | '/' factor
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (factor := self.factor())
        ):
            return [literal, factor]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('/'))
            and
            (factor := self.factor())
        ):
            return [literal, factor]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_35(self):
        # _tmp_35: '.' NAME | '[' expression ']' | '(' arguments ','?? ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('.'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('['))
            and
            (expression := self.expression())
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, expression, literal_1]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (opt := self._tmp_37(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_36(self):
        # _tmp_36: ',' kwarg
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (kwarg := self.kwarg())
        ):
            return [literal, kwarg]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_37(self):
        # _tmp_37: arguments ','?
        mark = self.mark()
        cut = False
        if (
            (arguments := self.arguments())
            and
            (opt := self.expect(','),)
        ):
            return [arguments, opt]
        self.reset(mark)
        if cut: return None
        return None


if __name__ == '__main__':
    from pegen import simple_parser_main
    simple_parser_main(GeneratedParser)
