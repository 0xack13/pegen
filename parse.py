#!/usr/bin/env python3.8
# @generated by pegen.py from testdata/grammar.gram
from __future__ import annotations

import sys
import tokenize

from pegen import memoize, Parser, Tokenizer, Tree


class GeneratedParser(Parser):

    @memoize
    def start(self):
        mark = self.mark()
        # Alt(NAME(value='statements'), NAME(value='ENDMARKER'))
        if (
            (statements := self.statements())
            and
            self.expect('ENDMARKER')
        ):
            return Tree('start', statements)
        self.reset(mark)
        return None

    @memoize
    def statements(self):
        mark = self.mark()
        children = []
        # statement
        while (
            (statement := self.statement())
        ):
            mark = self.mark()
            children.append(Tree('statements', statement))
        self.reset(mark)
        if children:
            return Tree('Repeat', *children)
        return None

    @memoize
    def statement(self):
        mark = self.mark()
        # simple_stmt
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return Tree('statement', simple_stmt)
        self.reset(mark)
        # compound_stmt
        if (
            (compound_stmt := self.compound_stmt())
        ):
            return Tree('statement', compound_stmt)
        self.reset(mark)
        return None

    @memoize
    def simple_stmt(self):
        mark = self.mark()
        # Alt(NAME(value='small_stmt'), ZeroOrMore(Alt(STRING(value="';'"), NAME(value='small_stmt'))), NAME(value='NEWLINE'))
        if (
            (small_stmt := self.small_stmt())
            and
            (_zeroormore__tmp_1 := self._zeroormore__tmp_1())
            and
            self.expect('NEWLINE')
        ):
            return Tree('simple_stmt', small_stmt, _zeroormore__tmp_1)
        self.reset(mark)
        return None

    @memoize
    def small_stmt(self):
        mark = self.mark()
        # return_stmt
        if (
            (return_stmt := self.return_stmt())
        ):
            return Tree('small_stmt', return_stmt)
        self.reset(mark)
        # import_stmt
        if (
            (import_stmt := self.import_stmt())
        ):
            return Tree('small_stmt', import_stmt)
        self.reset(mark)
        # 'pass'
        if (
            self.expect('pass')
        ):
            return Tree('small_stmt', )
        self.reset(mark)
        # assignment
        if (
            (assignment := self.assignment())
        ):
            return Tree('small_stmt', assignment)
        self.reset(mark)
        # expression
        if (
            (expression := self.expression())
        ):
            return Tree('small_stmt', expression)
        self.reset(mark)
        return None

    @memoize
    def compound_stmt(self):
        mark = self.mark()
        # if_stmt
        if (
            (if_stmt := self.if_stmt())
        ):
            return Tree('compound_stmt', if_stmt)
        self.reset(mark)
        # while_stmt
        if (
            (while_stmt := self.while_stmt())
        ):
            return Tree('compound_stmt', while_stmt)
        self.reset(mark)
        # with_stmt
        if (
            (with_stmt := self.with_stmt())
        ):
            return Tree('compound_stmt', with_stmt)
        self.reset(mark)
        # function_def
        if (
            (function_def := self.function_def())
        ):
            return Tree('compound_stmt', function_def)
        self.reset(mark)
        # class_def
        if (
            (class_def := self.class_def())
        ):
            return Tree('compound_stmt', class_def)
        self.reset(mark)
        return None

    @memoize
    def assignment(self):
        mark = self.mark()
        # Alt(NAME(value='target'), STRING(value="'='"), NAME(value='expression'))
        if (
            (target := self.target())
            and
            self.expect('=')
            and
            (expression := self.expression())
        ):
            return Tree('assignment', target, expression)
        self.reset(mark)
        return None

    @memoize
    def import_stmt(self):
        mark = self.mark()
        # Alt(STRING(value="'import'"), NAME(value='names'))
        if (
            self.expect('import')
            and
            (names := self.names())
        ):
            return Tree('import_stmt', names)
        self.reset(mark)
        # Alt(STRING(value="'from'"), NAME(value='NAME'), STRING(value="'import'"), Alts(STRING(value="'*'"), NAME(value='names')))
        if (
            self.expect('from')
            and
            (name := self.name())
            and
            self.expect('import')
            and
            (_tmp_2 := self._tmp_2())
        ):
            return Tree('import_stmt', name, _tmp_2)
        self.reset(mark)
        return None

    @memoize
    def names(self):
        mark = self.mark()
        # Alt(NAME(value='NAME'), STRING(value="','"), NAME(value='names'))
        if (
            (name := self.name())
            and
            self.expect(',')
            and
            (names := self.names())
        ):
            return Tree('names', name, names)
        self.reset(mark)
        # NAME
        if (
            (name := self.name())
        ):
            return Tree('names', name)
        self.reset(mark)
        return None

    @memoize
    def if_stmt(self):
        mark = self.mark()
        # Alt(STRING(value="'if'"), NAME(value='full_expression'), STRING(value="':'"), NAME(value='block'), ZeroOrMore(NAME(value='elif_block')), Opt(NAME(value='else_block')))
        if (
            self.expect('if')
            and
            (full_expression := self.full_expression())
            and
            self.expect(':')
            and
            (block := self.block())
            and
            (_zeroormore_elif_block := self._zeroormore_elif_block())
            and
            (_opt_else_block := self._opt_else_block())
        ):
            return Tree('if_stmt', full_expression, block, _zeroormore_elif_block, _opt_else_block)
        self.reset(mark)
        return None

    @memoize
    def elif_block(self):
        mark = self.mark()
        # Alt(STRING(value="'elif'"), NAME(value='full_expression'), STRING(value="':'"), NAME(value='block'))
        if (
            self.expect('elif')
            and
            (full_expression := self.full_expression())
            and
            self.expect(':')
            and
            (block := self.block())
        ):
            return Tree('elif_block', full_expression, block)
        self.reset(mark)
        return None

    @memoize
    def else_block(self):
        mark = self.mark()
        # Alt(STRING(value="'else'"), STRING(value="':'"), NAME(value='block'))
        if (
            self.expect('else')
            and
            self.expect(':')
            and
            (block := self.block())
        ):
            return Tree('else_block', block)
        self.reset(mark)
        return None

    @memoize
    def while_stmt(self):
        mark = self.mark()
        # Alt(STRING(value="'while'"), NAME(value='full_expression'), STRING(value="':'"), NAME(value='block'), Opt(NAME(value='else_block')))
        if (
            self.expect('while')
            and
            (full_expression := self.full_expression())
            and
            self.expect(':')
            and
            (block := self.block())
            and
            (_opt_else_block := self._opt_else_block())
        ):
            return Tree('while_stmt', full_expression, block, _opt_else_block)
        self.reset(mark)
        return None

    @memoize
    def with_stmt(self):
        mark = self.mark()
        # Alt(STRING(value="'with'"), NAME(value='expression'), Opt(Alt(STRING(value="'as'"), NAME(value='target'))), STRING(value="':'"), NAME(value='block'))
        if (
            self.expect('with')
            and
            (expression := self.expression())
            and
            (_opt__tmp_3 := self._opt__tmp_3())
            and
            self.expect(':')
            and
            (block := self.block())
        ):
            return Tree('with_stmt', expression, _opt__tmp_3, block)
        self.reset(mark)
        return None

    @memoize
    def return_stmt(self):
        mark = self.mark()
        # Alt(STRING(value="'return'"), Opt(NAME(value='expressions')))
        if (
            self.expect('return')
            and
            (_opt_expressions := self._opt_expressions())
        ):
            return Tree('return_stmt', _opt_expressions)
        self.reset(mark)
        return None

    @memoize
    def function_def(self):
        mark = self.mark()
        # Alt(Opt(NAME(value='decorators')), STRING(value="'def'"), NAME(value='NAME'), STRING(value="'('"), Opt(NAME(value='parameters')), STRING(value="')'"), STRING(value="':'"), NAME(value='block'))
        if (
            (_opt_decorators := self._opt_decorators())
            and
            self.expect('def')
            and
            (name := self.name())
            and
            self.expect('(')
            and
            (_opt_parameters := self._opt_parameters())
            and
            self.expect(')')
            and
            self.expect(':')
            and
            (block := self.block())
        ):
            return Tree('function_def', _opt_decorators, name, _opt_parameters, block)
        self.reset(mark)
        return None

    @memoize
    def parameters(self):
        mark = self.mark()
        # kwparams
        if (
            (kwparams := self.kwparams())
        ):
            return Tree('parameters', kwparams)
        self.reset(mark)
        # Alt(NAME(value='param'), Opt(Alt(STRING(value="','"), Opt(NAME(value='parameters')))))
        if (
            (param := self.param())
            and
            (_opt__tmp_4 := self._opt__tmp_4())
        ):
            return Tree('parameters', param, _opt__tmp_4)
        self.reset(mark)
        return None

    @memoize
    def kwparams(self):
        mark = self.mark()
        # Alt(NAME(value='kwparam'), Opt(Alt(STRING(value="','"), Opt(NAME(value='kwparams')))))
        if (
            (kwparam := self.kwparam())
            and
            (_opt__tmp_5 := self._opt__tmp_5())
        ):
            return Tree('kwparams', kwparam, _opt__tmp_5)
        self.reset(mark)
        return None

    @memoize
    def kwparam(self):
        mark = self.mark()
        # Alt(NAME(value='NAME'), STRING(value="'='"), NAME(value='expression'))
        if (
            (name := self.name())
            and
            self.expect('=')
            and
            (expression := self.expression())
        ):
            return Tree('kwparam', name, expression)
        self.reset(mark)
        # Alt(STRING(value="'**'"), NAME(value='NAME'))
        if (
            self.expect('**')
            and
            (name := self.name())
        ):
            return Tree('kwparam', name)
        self.reset(mark)
        return None

    @memoize
    def param(self):
        mark = self.mark()
        # NAME
        if (
            (name := self.name())
        ):
            return Tree('param', name)
        self.reset(mark)
        # Alt(STRING(value="'*'"), NAME(value='NAME'))
        if (
            self.expect('*')
            and
            (name := self.name())
        ):
            return Tree('param', name)
        self.reset(mark)
        return None

    @memoize
    def decorators(self):
        mark = self.mark()
        children = []
        # Alt(STRING(value="'@'"), NAME(value='factor'), NAME(value='NEWLINE'))
        while (
            self.expect('@')
            and
            (factor := self.factor())
            and
            self.expect('NEWLINE')
        ):
            mark = self.mark()
            children.append(Tree('decorators', factor))
        self.reset(mark)
        if children:
            return Tree('Repeat', *children)
        return None

    @memoize
    def class_def(self):
        mark = self.mark()
        # Alt(Opt(NAME(value='decorators')), STRING(value="'class'"), NAME(value='NAME'), Opt(Alt(STRING(value="'('"), NAME(value='full_expressions'), STRING(value="')'"))), STRING(value="':'"), NAME(value='block'))
        if (
            (_opt_decorators := self._opt_decorators())
            and
            self.expect('class')
            and
            (name := self.name())
            and
            (_opt__tmp_6 := self._opt__tmp_6())
            and
            self.expect(':')
            and
            (block := self.block())
        ):
            return Tree('class_def', _opt_decorators, name, _opt__tmp_6, block)
        self.reset(mark)
        return None

    @memoize
    def block(self):
        mark = self.mark()
        # simple_stmt
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return Tree('block', simple_stmt)
        self.reset(mark)
        # Alt(NAME(value='NEWLINE'), NAME(value='INDENT'), NAME(value='statements'), NAME(value='DEDENT'))
        if (
            self.expect('NEWLINE')
            and
            self.expect('INDENT')
            and
            (statements := self.statements())
            and
            self.expect('DEDENT')
        ):
            return Tree('block', statements)
        self.reset(mark)
        return None

    @memoize
    def full_expressions(self):
        mark = self.mark()
        # Alt(NAME(value='full_expression'), ZeroOrMore(Alt(STRING(value="','"), NAME(value='full_expression'))), Opt(STRING(value="','")))
        if (
            (full_expression := self.full_expression())
            and
            (_zeroormore__tmp_7 := self._zeroormore__tmp_7())
            and
            (_opt__tmp_8 := self._opt__tmp_8())
        ):
            return Tree('full_expressions', full_expression, _zeroormore__tmp_7, _opt__tmp_8)
        self.reset(mark)
        return None

    @memoize
    def full_expression(self):
        mark = self.mark()
        # Alt(NAME(value='NAME'), STRING(value="':='"), NAME(value='disjunction'))
        if (
            (name := self.name())
            and
            self.expect(':=')
            and
            (disjunction := self.disjunction())
        ):
            return Tree('full_expression', name, disjunction)
        self.reset(mark)
        # disjunction
        if (
            (disjunction := self.disjunction())
        ):
            return Tree('full_expression', disjunction)
        self.reset(mark)
        return None

    @memoize
    def disjunction(self):
        mark = self.mark()
        # Alt(NAME(value='conjunction'), ZeroOrMore(Alt(STRING(value="'or'"), NAME(value='conjunction'))))
        if (
            (conjunction := self.conjunction())
            and
            (_zeroormore__tmp_9 := self._zeroormore__tmp_9())
        ):
            return Tree('disjunction', conjunction, _zeroormore__tmp_9)
        self.reset(mark)
        return None

    @memoize
    def conjunction(self):
        mark = self.mark()
        # Alt(NAME(value='comparison'), ZeroOrMore(Alt(STRING(value="'and'"), NAME(value='comparison'))))
        if (
            (comparison := self.comparison())
            and
            (_zeroormore__tmp_10 := self._zeroormore__tmp_10())
        ):
            return Tree('conjunction', comparison, _zeroormore__tmp_10)
        self.reset(mark)
        return None

    @memoize
    def comparison(self):
        mark = self.mark()
        # Alt(ZeroOrMore(STRING(value="'not'")), NAME(value='bitwise_or'), ZeroOrMore(Alt(NAME(value='compare_op'), NAME(value='bitwise_or'))))
        if (
            (_zeroormore__tmp_11 := self._zeroormore__tmp_11())
            and
            (bitwise_or := self.bitwise_or())
            and
            (_zeroormore__tmp_12 := self._zeroormore__tmp_12())
        ):
            return Tree('comparison', _zeroormore__tmp_11, bitwise_or, _zeroormore__tmp_12)
        self.reset(mark)
        return None

    @memoize
    def compare_op(self):
        mark = self.mark()
        # '<'
        if (
            self.expect('<')
        ):
            return Tree('compare_op', )
        self.reset(mark)
        # '<='
        if (
            self.expect('<=')
        ):
            return Tree('compare_op', )
        self.reset(mark)
        # '=='
        if (
            self.expect('==')
        ):
            return Tree('compare_op', )
        self.reset(mark)
        # '>='
        if (
            self.expect('>=')
        ):
            return Tree('compare_op', )
        self.reset(mark)
        # '>'
        if (
            self.expect('>')
        ):
            return Tree('compare_op', )
        self.reset(mark)
        # '!='
        if (
            self.expect('!=')
        ):
            return Tree('compare_op', )
        self.reset(mark)
        # 'in'
        if (
            self.expect('in')
        ):
            return Tree('compare_op', )
        self.reset(mark)
        # 'not in'
        if (
            self.expect('not in')
        ):
            return Tree('compare_op', )
        self.reset(mark)
        return None

    @memoize
    def bitwise_or(self):
        mark = self.mark()
        # Alt(NAME(value='bitwise_and'), ZeroOrMore(Alt(STRING(value="'|'"), NAME(value='bitwise_and'))))
        if (
            (bitwise_and := self.bitwise_and())
            and
            (_zeroormore__tmp_13 := self._zeroormore__tmp_13())
        ):
            return Tree('bitwise_or', bitwise_and, _zeroormore__tmp_13)
        self.reset(mark)
        return None

    @memoize
    def bitwise_and(self):
        mark = self.mark()
        # Alt(NAME(value='expression'), ZeroOrMore(Alt(STRING(value="'&'"), NAME(value='expression'))))
        if (
            (expression := self.expression())
            and
            (_zeroormore__tmp_14 := self._zeroormore__tmp_14())
        ):
            return Tree('bitwise_and', expression, _zeroormore__tmp_14)
        self.reset(mark)
        return None

    @memoize
    def expressions(self):
        mark = self.mark()
        # Alt(NAME(value='expression'), ZeroOrMore(Alt(STRING(value="','"), NAME(value='expression'))), Opt(STRING(value="','")))
        if (
            (expression := self.expression())
            and
            (_zeroormore__tmp_15 := self._zeroormore__tmp_15())
            and
            (_opt__tmp_16 := self._opt__tmp_16())
        ):
            return Tree('expressions', expression, _zeroormore__tmp_15, _opt__tmp_16)
        self.reset(mark)
        return None

    @memoize
    def expression(self):
        mark = self.mark()
        # Alt(NAME(value='term'), ZeroOrMore(Alts(Alt(STRING(value="'+'"), NAME(value='term')), Alt(STRING(value="'-'"), NAME(value='term')))))
        if (
            (term := self.term())
            and
            (_zeroormore__tmp_17 := self._zeroormore__tmp_17())
        ):
            return Tree('expression', term, _zeroormore__tmp_17)
        self.reset(mark)
        return None

    @memoize
    def term(self):
        mark = self.mark()
        # Alt(NAME(value='factor'), ZeroOrMore(Alts(Alt(STRING(value="'*'"), NAME(value='factor')), Alt(STRING(value="'/'"), NAME(value='factor')))))
        if (
            (factor := self.factor())
            and
            (_zeroormore__tmp_18 := self._zeroormore__tmp_18())
        ):
            return Tree('term', factor, _zeroormore__tmp_18)
        self.reset(mark)
        return None

    @memoize
    def factor(self):
        mark = self.mark()
        # Alt(NAME(value='primary'), ZeroOrMore(Alts(Alt(STRING(value="'.'"), NAME(value='NAME')), Alt(STRING(value="'['"), NAME(value='expression'), STRING(value="']'")), Alt(STRING(value="'('"), Opt(Alt(NAME(value='arguments'), Opt(STRING(value="','")))), STRING(value="')'")))))
        if (
            (primary := self.primary())
            and
            (_zeroormore__tmp_19 := self._zeroormore__tmp_19())
        ):
            return Tree('factor', primary, _zeroormore__tmp_19)
        self.reset(mark)
        return None

    @memoize
    def primary(self):
        mark = self.mark()
        # list
        if (
            (list := self.list())
        ):
            return Tree('primary', list)
        self.reset(mark)
        # tuple
        if (
            (tuple := self.tuple())
        ):
            return Tree('primary', tuple)
        self.reset(mark)
        # group
        if (
            (group := self.group())
        ):
            return Tree('primary', group)
        self.reset(mark)
        # NAME
        if (
            (name := self.name())
        ):
            return Tree('primary', name)
        self.reset(mark)
        # STRING
        if (
            (string := self.string())
        ):
            return Tree('primary', string)
        self.reset(mark)
        # NUMBER
        if (
            (number := self.number())
        ):
            return Tree('primary', number)
        self.reset(mark)
        return None

    @memoize
    def list(self):
        mark = self.mark()
        # Alt(STRING(value="'['"), Opt(NAME(value='full_expressions')), STRING(value="']'"))
        if (
            self.expect('[')
            and
            (_opt_full_expressions := self._opt_full_expressions())
            and
            self.expect(']')
        ):
            return Tree('list', _opt_full_expressions)
        self.reset(mark)
        return None

    @memoize
    def tuple(self):
        mark = self.mark()
        # Alt(STRING(value="'('"), Opt(Alt(NAME(value='full_expression'), STRING(value="','"), Opt(NAME(value='full_expressions')))), STRING(value="')'"))
        if (
            self.expect('(')
            and
            (_opt__tmp_20 := self._opt__tmp_20())
            and
            self.expect(')')
        ):
            return Tree('tuple', _opt__tmp_20)
        self.reset(mark)
        return None

    @memoize
    def group(self):
        mark = self.mark()
        # Alt(STRING(value="'('"), NAME(value='full_expression'), STRING(value="')'"))
        if (
            self.expect('(')
            and
            (full_expression := self.full_expression())
            and
            self.expect(')')
        ):
            return Tree('group', full_expression)
        self.reset(mark)
        return None

    @memoize
    def arguments(self):
        mark = self.mark()
        # kwargs
        if (
            (kwargs := self.kwargs())
        ):
            return Tree('arguments', kwargs)
        self.reset(mark)
        # Alt(NAME(value='posarg'), Opt(Alt(STRING(value="','"), NAME(value='arguments'))))
        if (
            (posarg := self.posarg())
            and
            (_opt__tmp_21 := self._opt__tmp_21())
        ):
            return Tree('arguments', posarg, _opt__tmp_21)
        self.reset(mark)
        return None

    @memoize
    def kwargs(self):
        mark = self.mark()
        # Alt(NAME(value='kwarg'), ZeroOrMore(Alt(STRING(value="','"), NAME(value='kwarg'))))
        if (
            (kwarg := self.kwarg())
            and
            (_zeroormore__tmp_22 := self._zeroormore__tmp_22())
        ):
            return Tree('kwargs', kwarg, _zeroormore__tmp_22)
        self.reset(mark)
        return None

    @memoize
    def posarg(self):
        mark = self.mark()
        # full_expression
        if (
            (full_expression := self.full_expression())
        ):
            return Tree('posarg', full_expression)
        self.reset(mark)
        # Alt(STRING(value="'*'"), NAME(value='disjunction'))
        if (
            self.expect('*')
            and
            (disjunction := self.disjunction())
        ):
            return Tree('posarg', disjunction)
        self.reset(mark)
        return None

    @memoize
    def kwarg(self):
        mark = self.mark()
        # Alt(NAME(value='NAME'), STRING(value="'='"), NAME(value='disjunction'))
        if (
            (name := self.name())
            and
            self.expect('=')
            and
            (disjunction := self.disjunction())
        ):
            return Tree('kwarg', name, disjunction)
        self.reset(mark)
        # Alt(STRING(value="'**'"), NAME(value='disjunction'))
        if (
            self.expect('**')
            and
            (disjunction := self.disjunction())
        ):
            return Tree('kwarg', disjunction)
        self.reset(mark)
        return None

    @memoize
    def target(self):
        mark = self.mark()
        # NAME
        if (
            (name := self.name())
        ):
            return Tree('target', name)
        self.reset(mark)
        return None

    @memoize
    def _tmp_1(self):
        mark = self.mark()
        # Alt(STRING(value="';'"), NAME(value='small_stmt'))
        if (
            self.expect(';')
            and
            (small_stmt := self.small_stmt())
        ):
            return small_stmt
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_1(self):
        mark = self.mark()
        children = []
        # Alt(STRING(value="';'"), NAME(value='small_stmt'))
        while (
            self.expect(';')
            and
            (small_stmt := self.small_stmt())
        ):
            mark = self.mark()
            children.append(small_stmt)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_2(self):
        mark = self.mark()
        # '*'
        if (
            self.expect('*')
        ):
            return Tree('_tmp_2', )
        self.reset(mark)
        # names
        if (
            (names := self.names())
        ):
            return names
        self.reset(mark)
        return None

    @memoize
    def _zeroormore_elif_block(self):
        mark = self.mark()
        children = []
        # elif_block
        while (
            (elif_block := self.elif_block())
        ):
            mark = self.mark()
            children.append(elif_block)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _opt_else_block(self):
        mark = self.mark()
        # Opt(NAME(value='else_block'))
        if (
            (else_block := self.else_block())
        ):
            return else_block
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_3(self):
        mark = self.mark()
        # Alt(STRING(value="'as'"), NAME(value='target'))
        if (
            self.expect('as')
            and
            (target := self.target())
        ):
            return target
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_3(self):
        mark = self.mark()
        # Opt(Alt(STRING(value="'as'"), NAME(value='target')))
        if (
            (_tmp_23 := self._tmp_23())
        ):
            return _tmp_23
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _opt_expressions(self):
        mark = self.mark()
        # Opt(NAME(value='expressions'))
        if (
            (expressions := self.expressions())
        ):
            return expressions
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _opt_decorators(self):
        mark = self.mark()
        # Opt(NAME(value='decorators'))
        if (
            (decorators := self.decorators())
        ):
            return decorators
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _opt_parameters(self):
        mark = self.mark()
        # Opt(NAME(value='parameters'))
        if (
            (parameters := self.parameters())
        ):
            return parameters
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_4(self):
        mark = self.mark()
        # Alt(STRING(value="','"), Opt(NAME(value='parameters')))
        if (
            self.expect(',')
            and
            (_opt_parameters := self._opt_parameters())
        ):
            return _opt_parameters
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_4(self):
        mark = self.mark()
        # Opt(Alt(STRING(value="','"), Opt(NAME(value='parameters'))))
        if (
            (_tmp_24 := self._tmp_24())
        ):
            return _tmp_24
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_5(self):
        mark = self.mark()
        # Alt(STRING(value="','"), Opt(NAME(value='kwparams')))
        if (
            self.expect(',')
            and
            (_opt_kwparams := self._opt_kwparams())
        ):
            return _opt_kwparams
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_5(self):
        mark = self.mark()
        # Opt(Alt(STRING(value="','"), Opt(NAME(value='kwparams'))))
        if (
            (_tmp_25 := self._tmp_25())
        ):
            return _tmp_25
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_6(self):
        mark = self.mark()
        # Alt(STRING(value="'('"), NAME(value='full_expressions'), STRING(value="')'"))
        if (
            self.expect('(')
            and
            (full_expressions := self.full_expressions())
            and
            self.expect(')')
        ):
            return full_expressions
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_6(self):
        mark = self.mark()
        # Opt(Alt(STRING(value="'('"), NAME(value='full_expressions'), STRING(value="')'")))
        if (
            (_tmp_26 := self._tmp_26())
        ):
            return _tmp_26
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_7(self):
        mark = self.mark()
        # Alt(STRING(value="','"), NAME(value='full_expression'))
        if (
            self.expect(',')
            and
            (full_expression := self.full_expression())
        ):
            return full_expression
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_7(self):
        mark = self.mark()
        children = []
        # Alt(STRING(value="','"), NAME(value='full_expression'))
        while (
            self.expect(',')
            and
            (full_expression := self.full_expression())
        ):
            mark = self.mark()
            children.append(full_expression)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_8(self):
        mark = self.mark()
        # ','
        if (
            self.expect(',')
        ):
            return Tree('_tmp_8', )
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_8(self):
        mark = self.mark()
        # Opt(STRING(value="','"))
        if (
            self.expect(',')
        ):
            return Tree('_opt__tmp_8', )
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_9(self):
        mark = self.mark()
        # Alt(STRING(value="'or'"), NAME(value='conjunction'))
        if (
            self.expect('or')
            and
            (conjunction := self.conjunction())
        ):
            return conjunction
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_9(self):
        mark = self.mark()
        children = []
        # Alt(STRING(value="'or'"), NAME(value='conjunction'))
        while (
            self.expect('or')
            and
            (conjunction := self.conjunction())
        ):
            mark = self.mark()
            children.append(conjunction)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_10(self):
        mark = self.mark()
        # Alt(STRING(value="'and'"), NAME(value='comparison'))
        if (
            self.expect('and')
            and
            (comparison := self.comparison())
        ):
            return comparison
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_10(self):
        mark = self.mark()
        children = []
        # Alt(STRING(value="'and'"), NAME(value='comparison'))
        while (
            self.expect('and')
            and
            (comparison := self.comparison())
        ):
            mark = self.mark()
            children.append(comparison)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_11(self):
        mark = self.mark()
        # 'not'
        if (
            self.expect('not')
        ):
            return Tree('_tmp_11', )
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_11(self):
        mark = self.mark()
        children = []
        # 'not'
        while (
            self.expect('not')
        ):
            mark = self.mark()
            children.append(Tree('_zeroormore__tmp_11', ))
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_12(self):
        mark = self.mark()
        # Alt(NAME(value='compare_op'), NAME(value='bitwise_or'))
        if (
            (compare_op := self.compare_op())
            and
            (bitwise_or := self.bitwise_or())
        ):
            return Tree('_tmp_12', compare_op, bitwise_or)
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_12(self):
        mark = self.mark()
        children = []
        # Alt(NAME(value='compare_op'), NAME(value='bitwise_or'))
        while (
            (compare_op := self.compare_op())
            and
            (bitwise_or := self.bitwise_or())
        ):
            mark = self.mark()
            children.append(Tree('_zeroormore__tmp_12', compare_op, bitwise_or))
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_13(self):
        mark = self.mark()
        # Alt(STRING(value="'|'"), NAME(value='bitwise_and'))
        if (
            self.expect('|')
            and
            (bitwise_and := self.bitwise_and())
        ):
            return bitwise_and
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_13(self):
        mark = self.mark()
        children = []
        # Alt(STRING(value="'|'"), NAME(value='bitwise_and'))
        while (
            self.expect('|')
            and
            (bitwise_and := self.bitwise_and())
        ):
            mark = self.mark()
            children.append(bitwise_and)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_14(self):
        mark = self.mark()
        # Alt(STRING(value="'&'"), NAME(value='expression'))
        if (
            self.expect('&')
            and
            (expression := self.expression())
        ):
            return expression
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_14(self):
        mark = self.mark()
        children = []
        # Alt(STRING(value="'&'"), NAME(value='expression'))
        while (
            self.expect('&')
            and
            (expression := self.expression())
        ):
            mark = self.mark()
            children.append(expression)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_15(self):
        mark = self.mark()
        # Alt(STRING(value="','"), NAME(value='expression'))
        if (
            self.expect(',')
            and
            (expression := self.expression())
        ):
            return expression
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_15(self):
        mark = self.mark()
        children = []
        # Alt(STRING(value="','"), NAME(value='expression'))
        while (
            self.expect(',')
            and
            (expression := self.expression())
        ):
            mark = self.mark()
            children.append(expression)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_16(self):
        mark = self.mark()
        # ','
        if (
            self.expect(',')
        ):
            return Tree('_tmp_16', )
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_16(self):
        mark = self.mark()
        # Opt(STRING(value="','"))
        if (
            self.expect(',')
        ):
            return Tree('_opt__tmp_16', )
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_17(self):
        mark = self.mark()
        # Alt(STRING(value="'+'"), NAME(value='term'))
        if (
            self.expect('+')
            and
            (term := self.term())
        ):
            return term
        self.reset(mark)
        # Alt(STRING(value="'-'"), NAME(value='term'))
        if (
            self.expect('-')
            and
            (term := self.term())
        ):
            return term
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_17(self):
        mark = self.mark()
        children = []
        # Alts(Alt(STRING(value="'+'"), NAME(value='term')), Alt(STRING(value="'-'"), NAME(value='term')))
        while (
            (_tmp_27 := self._tmp_27())
        ):
            mark = self.mark()
            children.append(_tmp_27)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_18(self):
        mark = self.mark()
        # Alt(STRING(value="'*'"), NAME(value='factor'))
        if (
            self.expect('*')
            and
            (factor := self.factor())
        ):
            return factor
        self.reset(mark)
        # Alt(STRING(value="'/'"), NAME(value='factor'))
        if (
            self.expect('/')
            and
            (factor := self.factor())
        ):
            return factor
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_18(self):
        mark = self.mark()
        children = []
        # Alts(Alt(STRING(value="'*'"), NAME(value='factor')), Alt(STRING(value="'/'"), NAME(value='factor')))
        while (
            (_tmp_28 := self._tmp_28())
        ):
            mark = self.mark()
            children.append(_tmp_28)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_19(self):
        mark = self.mark()
        # Alt(STRING(value="'.'"), NAME(value='NAME'))
        if (
            self.expect('.')
            and
            (name := self.name())
        ):
            return name
        self.reset(mark)
        # Alt(STRING(value="'['"), NAME(value='expression'), STRING(value="']'"))
        if (
            self.expect('[')
            and
            (expression := self.expression())
            and
            self.expect(']')
        ):
            return expression
        self.reset(mark)
        # Alt(STRING(value="'('"), Opt(Alt(NAME(value='arguments'), Opt(STRING(value="','")))), STRING(value="')'"))
        if (
            self.expect('(')
            and
            (_opt__tmp_29 := self._opt__tmp_29())
            and
            self.expect(')')
        ):
            return _opt__tmp_29
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_19(self):
        mark = self.mark()
        children = []
        # Alts(Alt(STRING(value="'.'"), NAME(value='NAME')), Alt(STRING(value="'['"), NAME(value='expression'), STRING(value="']'")), Alt(STRING(value="'('"), Opt(Alt(NAME(value='arguments'), Opt(STRING(value="','")))), STRING(value="')'")))
        while (
            (_tmp_30 := self._tmp_30())
        ):
            mark = self.mark()
            children.append(_tmp_30)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _opt_full_expressions(self):
        mark = self.mark()
        # Opt(NAME(value='full_expressions'))
        if (
            (full_expressions := self.full_expressions())
        ):
            return full_expressions
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_20(self):
        mark = self.mark()
        # Alt(NAME(value='full_expression'), STRING(value="','"), Opt(NAME(value='full_expressions')))
        if (
            (full_expression := self.full_expression())
            and
            self.expect(',')
            and
            (_opt_full_expressions := self._opt_full_expressions())
        ):
            return Tree('_tmp_20', full_expression, _opt_full_expressions)
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_20(self):
        mark = self.mark()
        # Opt(Alt(NAME(value='full_expression'), STRING(value="','"), Opt(NAME(value='full_expressions'))))
        if (
            (_tmp_31 := self._tmp_31())
        ):
            return _tmp_31
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_21(self):
        mark = self.mark()
        # Alt(STRING(value="','"), NAME(value='arguments'))
        if (
            self.expect(',')
            and
            (arguments := self.arguments())
        ):
            return arguments
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_21(self):
        mark = self.mark()
        # Opt(Alt(STRING(value="','"), NAME(value='arguments')))
        if (
            (_tmp_32 := self._tmp_32())
        ):
            return _tmp_32
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_22(self):
        mark = self.mark()
        # Alt(STRING(value="','"), NAME(value='kwarg'))
        if (
            self.expect(',')
            and
            (kwarg := self.kwarg())
        ):
            return kwarg
        self.reset(mark)
        return None

    @memoize
    def _zeroormore__tmp_22(self):
        mark = self.mark()
        children = []
        # Alt(STRING(value="','"), NAME(value='kwarg'))
        while (
            self.expect(',')
            and
            (kwarg := self.kwarg())
        ):
            mark = self.mark()
            children.append(kwarg)
        self.reset(mark)
        return Tree('Repeat', *children)

    @memoize
    def _tmp_23(self):
        mark = self.mark()
        # Alt(STRING(value="'as'"), NAME(value='target'))
        if (
            self.expect('as')
            and
            (target := self.target())
        ):
            return target
        self.reset(mark)
        return None

    @memoize
    def _tmp_24(self):
        mark = self.mark()
        # Alt(STRING(value="','"), Opt(NAME(value='parameters')))
        if (
            self.expect(',')
            and
            (_opt_parameters := self._opt_parameters())
        ):
            return _opt_parameters
        self.reset(mark)
        return None

    @memoize
    def _opt_kwparams(self):
        mark = self.mark()
        # Opt(NAME(value='kwparams'))
        if (
            (kwparams := self.kwparams())
        ):
            return kwparams
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_25(self):
        mark = self.mark()
        # Alt(STRING(value="','"), Opt(NAME(value='kwparams')))
        if (
            self.expect(',')
            and
            (_opt_kwparams := self._opt_kwparams())
        ):
            return _opt_kwparams
        self.reset(mark)
        return None

    @memoize
    def _tmp_26(self):
        mark = self.mark()
        # Alt(STRING(value="'('"), NAME(value='full_expressions'), STRING(value="')'"))
        if (
            self.expect('(')
            and
            (full_expressions := self.full_expressions())
            and
            self.expect(')')
        ):
            return full_expressions
        self.reset(mark)
        return None

    @memoize
    def _tmp_27(self):
        mark = self.mark()
        # Alt(STRING(value="'+'"), NAME(value='term'))
        if (
            self.expect('+')
            and
            (term := self.term())
        ):
            return term
        self.reset(mark)
        # Alt(STRING(value="'-'"), NAME(value='term'))
        if (
            self.expect('-')
            and
            (term := self.term())
        ):
            return term
        self.reset(mark)
        return None

    @memoize
    def _tmp_28(self):
        mark = self.mark()
        # Alt(STRING(value="'*'"), NAME(value='factor'))
        if (
            self.expect('*')
            and
            (factor := self.factor())
        ):
            return factor
        self.reset(mark)
        # Alt(STRING(value="'/'"), NAME(value='factor'))
        if (
            self.expect('/')
            and
            (factor := self.factor())
        ):
            return factor
        self.reset(mark)
        return None

    @memoize
    def _tmp_29(self):
        mark = self.mark()
        # Alt(NAME(value='arguments'), Opt(STRING(value="','")))
        if (
            (arguments := self.arguments())
            and
            (_opt__tmp_33 := self._opt__tmp_33())
        ):
            return Tree('_tmp_29', arguments, _opt__tmp_33)
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_29(self):
        mark = self.mark()
        # Opt(Alt(NAME(value='arguments'), Opt(STRING(value="','"))))
        if (
            (_tmp_34 := self._tmp_34())
        ):
            return _tmp_34
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_30(self):
        mark = self.mark()
        # Alt(STRING(value="'.'"), NAME(value='NAME'))
        if (
            self.expect('.')
            and
            (name := self.name())
        ):
            return name
        self.reset(mark)
        # Alt(STRING(value="'['"), NAME(value='expression'), STRING(value="']'"))
        if (
            self.expect('[')
            and
            (expression := self.expression())
            and
            self.expect(']')
        ):
            return expression
        self.reset(mark)
        # Alt(STRING(value="'('"), Opt(Alt(NAME(value='arguments'), Opt(STRING(value="','")))), STRING(value="')'"))
        if (
            self.expect('(')
            and
            (_opt__tmp_35 := self._opt__tmp_35())
            and
            self.expect(')')
        ):
            return _opt__tmp_35
        self.reset(mark)
        return None

    @memoize
    def _tmp_31(self):
        mark = self.mark()
        # Alt(NAME(value='full_expression'), STRING(value="','"), Opt(NAME(value='full_expressions')))
        if (
            (full_expression := self.full_expression())
            and
            self.expect(',')
            and
            (_opt_full_expressions := self._opt_full_expressions())
        ):
            return Tree('_tmp_31', full_expression, _opt_full_expressions)
        self.reset(mark)
        return None

    @memoize
    def _tmp_32(self):
        mark = self.mark()
        # Alt(STRING(value="','"), NAME(value='arguments'))
        if (
            self.expect(',')
            and
            (arguments := self.arguments())
        ):
            return arguments
        self.reset(mark)
        return None

    @memoize
    def _tmp_33(self):
        mark = self.mark()
        # ','
        if (
            self.expect(',')
        ):
            return Tree('_tmp_33', )
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_33(self):
        mark = self.mark()
        # Opt(STRING(value="','"))
        if (
            self.expect(',')
        ):
            return Tree('_opt__tmp_33', )
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_34(self):
        mark = self.mark()
        # Alt(NAME(value='arguments'), Opt(STRING(value="','")))
        if (
            (arguments := self.arguments())
            and
            (_opt__tmp_36 := self._opt__tmp_36())
        ):
            return Tree('_tmp_34', arguments, _opt__tmp_36)
        self.reset(mark)
        return None

    @memoize
    def _tmp_35(self):
        mark = self.mark()
        # Alt(NAME(value='arguments'), Opt(STRING(value="','")))
        if (
            (arguments := self.arguments())
            and
            (_opt__tmp_37 := self._opt__tmp_37())
        ):
            return Tree('_tmp_35', arguments, _opt__tmp_37)
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_35(self):
        mark = self.mark()
        # Opt(Alt(NAME(value='arguments'), Opt(STRING(value="','"))))
        if (
            (_tmp_38 := self._tmp_38())
        ):
            return _tmp_38
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_36(self):
        mark = self.mark()
        # ','
        if (
            self.expect(',')
        ):
            return Tree('_tmp_36', )
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_36(self):
        mark = self.mark()
        # Opt(STRING(value="','"))
        if (
            self.expect(',')
        ):
            return Tree('_opt__tmp_36', )
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_37(self):
        mark = self.mark()
        # ','
        if (
            self.expect(',')
        ):
            return Tree('_tmp_37', )
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_37(self):
        mark = self.mark()
        # Opt(STRING(value="','"))
        if (
            self.expect(',')
        ):
            return Tree('_opt__tmp_37', )
        self.reset(mark)
        return Tree('Empty')

    @memoize
    def _tmp_38(self):
        mark = self.mark()
        # Alt(NAME(value='arguments'), Opt(STRING(value="','")))
        if (
            (arguments := self.arguments())
            and
            (_opt__tmp_39 := self._opt__tmp_39())
        ):
            return Tree('_tmp_38', arguments, _opt__tmp_39)
        self.reset(mark)
        return None

    @memoize
    def _tmp_39(self):
        mark = self.mark()
        # ','
        if (
            self.expect(',')
        ):
            return Tree('_tmp_39', )
        self.reset(mark)
        return None

    @memoize
    def _opt__tmp_39(self):
        mark = self.mark()
        # Opt(STRING(value="','"))
        if (
            self.expect(',')
        ):
            return Tree('_opt__tmp_39', )
        self.reset(mark)
        return Tree('Empty')


def main():
    import argparse, time, token
    from pegen import print_memstats
    argparser = argparse.ArgumentParser()
    argparser.add_argument('-v', '--verbose', action='count', default=0,
                           help="Print timing stats; repeat for more debug output")
    argparser.add_argument('-q', '--quiet', action='store_true',
                           help="Don't print the parsed program")
    argparser.add_argument('filename')
    args = argparser.parse_args()
    verbose = args.verbose
    verbose_tokenizer = verbose == 2 or verbose >= 4
    verbose_parser = verbose >= 3
    t0 = time.time()
    with open(args.filename) as file:
        tokenizer = Tokenizer(tokenize.generate_tokens(file.readline), verbose=verbose_tokenizer)
        parser = GeneratedParser(tokenizer, verbose=verbose_parser)
        tree = parser.start()
        endpos = file.tell()
    t1 = time.time()
    if not tree:
        print("Syntax error at:", tokenizer.diagnose(), file=sys.stderr)
        sys.exit(1)
    if not args.quiet:
        print(tree)
    if verbose:
        dt = t1 - t0
        diag = tokenizer.diagnose()
        nlines = diag.end[0]
        if diag.type == token.ENDMARKER:
            nlines -= 1
        print("Total time: %.3f sec; %d lines (%d bytes)" % (dt, nlines, endpos),
              end="", file=sys.stderr)
        if dt:
            print("; %.3f lines/sec" % (nlines / dt), file=sys.stderr)
        else:
            print(file=sys.stderr)
        print("Caches sizes:", file=sys.stderr)
        print(f"  token array : {len(tokenizer._tokens):10}", file=sys.stderr)
        print(f"  symbol cache: {len(parser._symbol_cache):10}", file=sys.stderr)
        print(f"  token cache : {len(parser._token_cache):10}", file=sys.stderr)
        print_memstats()


if __name__ == '__main__':
    main()
