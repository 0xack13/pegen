# Simplified grammar for Python

start: [statements] ENDMARKER
statements: statement+

# NOTE: assignment MUST precede expression, else the parser will get stuck
statement: simple_stmt | compound_stmt
simple_stmt: small_stmt (';' small_stmt)* NEWLINE
small_stmt: return_stmt | import_stmt | 'pass' | yield_stmt | assignment | expression
compound_stmt: if_stmt | while_stmt | for_stmt | with_stmt | try_stmt | function_def | class_def

assignment: target ':' expression ['=' expression] | targets '=' expressions | target iop expression
iop: '+=' | '-='  # etc.

yield_stmt: yield_expr

import_stmt: import_name | import_from
import_name: 'import' dotted_as_names
# note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
import_from: ('from' (('.' | '...')* dotted_name | ('.' | '...')+)
              'import' ('*' | '(' import_as_names ')' | import_as_names))
import_as_name: NAME ['as' NAME]
dotted_as_name: dotted_name ['as' NAME]
import_as_names: import_as_name (',' import_as_name)* [',']
dotted_as_names: dotted_as_name (',' dotted_as_name)*
dotted_name: NAME ('.' NAME)*

if_stmt: 'if' full_expression ':' block elif_block* [else_block]
elif_block: 'elif' full_expression ':' block
else_block: 'else' ':' block

while_stmt: 'while' full_expression ':' block [else_block]

for_stmt: 'for' targets 'in' expressions ':' block [else_block]

with_stmt: 'with' expression ['as' target] ':' block

try_stmt: try_block except_block* finally_block | try_block except_block
try_block: 'try' ':' block
except_block: 'except' [expression ['as' target]] ':' block
finally_block: 'finally' ':' block

return_stmt: 'return' [expressions]

function_def: [decorators] 'def' NAME '(' [parameters] ')' ['->' expression] ':' block
parameters: kwparams | param [',' [parameters]]
kwparams: kwparam [',' [kwparams]]
kwparam: NAME [':' expression] '=' expression | '**' NAME [':' expression]
param: NAME [':' expression] | '*' NAME [':' expression]
decorators: ('@' factor NEWLINE)+

class_def: [decorators] 'class' NAME ['(' full_expressions ')'] ':' block

block: simple_stmt | NEWLINE INDENT statements DEDENT

full_expressions: full_expression (',' full_expression)* [',']
full_expression: NAME ':=' disjunction | disjunction
disjunction: conjunction ('or' conjunction)*
conjunction: comparison ('and' comparison)*
comparison: 'not'* bitwise_or (compare_op bitwise_or)*
compare_op: '<' | '<=' | '==' | '>=' | '>' | '!=' | 'in' | 'not' 'in'

bitwise_or: bitwise_and ('|' bitwise_and)*
bitwise_and: expression ('&' expression)*

expressions: expression (',' expression)* [',']
expression: term (('+' term | '-' term))*
term: factor (('*' factor | '/' factor | '//' factor | '%' factor | '@' factor))*
factor: ('+' | '-' | '~') factor | power
power: primary '**' factor | primary
primary: atom ('.' NAME | '[' expression ']' | '(' [arguments [',']] ')')*
atom: list | listcomp | tuple | group | genexp | set | setcomp | dict | dictcomp | NAME | STRING | NUMBER
list: '[' [full_expressions] ']'
listcomp: '[' expression for_if_clauses ']'
tuple: '(' [full_expression ',' [full_expressions]] ')'
group: '(' full_expression | yield_expr ')'
genexp: '(' expression for_if_clauses ')'
set: '{' expressions '}'
setcomp: '{' expression for_if_clauses '}'
dict: '{' [kvpairs] '}'
dictcomp: '{' kvpair for_if_clauses '}'
kvpairs: kvpair (',' kvpair)* [',']
kvpair: expression ':' expression
for_if_clauses: ('for' targets 'in' expression ('if' expression)*)+

yield_expr: 'yield' 'from' expression | 'yield' [expression]

arguments: expression for_if_clauses | kwargs | posarg [',' arguments]  # Weird to make it work
kwargs: kwarg (',' kwarg)*
posarg: full_expression | '*' disjunction
kwarg: NAME '=' disjunction | '**' disjunction

targets: target (',' target)* [',']
target: atom '.' NAME | atom '[' expression ']' | NAME  # TODO: it's more complicated
